" vim: foldmethod=marker path=~/.local/share/nvim/vim-plug/ isf-=/ foldcolumn=3 tw=0 ts=8

let g:loaded_sql_completion = 160
let g:ftplugin_sql_omni_key = '<C-S-Q>'

let mapleader = "\<Space>"

augroup vimrc
    autocmd!
augroup END

let vim_plug_available = 0
let vim_plug_path='~/.local/share/nvim/site/autoload/plug.vim'
let vim_plug_url='https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim'
let vim_plug_getters = [
			\ { 'name': 'curl', 'command': '!curl --fail --location --create-dirs --output ' . vim_plug_path .  " " . vim_plug_url },
			\ { 'name': 'wget', 'command': '!wget' },
			\]

if empty(glob(vim_plug_path))
	for vim_plug_getter in vim_plug_getters
		echo vim_plug_getter.name . ': ' . vim_plug_getter.command
		execute('silent! ' . vim_plug_getter.command)

		if v:shell_error == 0
			let vim_plug_available = 1
			break
		endif
	endfor
else
	let vim_plug_available = 1
endif

" Plugins {{{
if vim_plug_available
	call plug#begin('~/.local/share/nvim/vim-plug')
	Plug 'junegunn/fzf' "{{{
	Plug 'junegunn/fzf.vim'
	let g:fzf_prefer_tmux = 0
	let g:fzf_command_prefix = 'Fzf'
	" TODO
	" -make edit of command default (not c-e)
	" -add support for Redir
	nmap <c-r> :FzfHistory:<cr>
	nmap <c-e> :FzfHistory/<cr>
	let g:fzf_tags_command = 'ctags -R'
	command! Colors call fzf#vim#colors({'right': '15%', 'options': '--reverse --height=100%'})
	" TODO: Make BLines/Lines support preview as well.
	" command! -bang -nargs=* FzfLines
	"		\ call fzf#vim#lines(<q-args>,
	"		\                 <bang>0 ? fzf#vim#with_preview('up:60%')
	"		\                         : fzf#vim#with_preview('right:50%'),
	"		\                 <bang>0)
	command! -bang -nargs=* FzfAg
		    \ call fzf#vim#ag(<q-args>,
		    \                 <bang>0 ? fzf#vim#with_preview('up:60%')
		    \                         : fzf#vim#with_preview('right:50%'),
		    \                 <bang>0)
	command! -bang -nargs=? -complete=dir Files call fzf#vim#files(<q-args>, fzf#vim#with_preview(), <bang>0)
	let g:fzf_layout = { 'down': '~70:%' }
	inoremap <expr> <c-x><c-l> fzf#complete('tmuxwords.rb --all-but-current --scroll 499 --min 5')
	imap <c-x><c-k> <plug>(fzf-complete-word)
	imap <c-x><c-f> <plug>(fzf-complete-path)
	" imap <c-x><c-L> <plug>(fzf-complete-line)
	nmap <leader><tab> <plug>(fzf-maps-n)
	xmap <leader><tab> <plug>(fzf-maps-x)
	omap <leader><tab> <plug>(fzf-maps-o)
	map <leader>T :FzfTags<cr>
	map <leader>M :FzfMarks<cr>
	map <leader>h :FzfHelptags<cr>
	map <leader>la :FzfAg<cr>
	map <leader>ll :FzfBLines<cr>
	map <leader>lL :FzfLines<cr>
	"
	nnoremap <silent> <Leader>` :FzfMarks<CR>
	function! GetSelected()
	    " save reg
	    let reg = '"'
	    let reg_save = getreg(reg)
	    let reg_type = getregtype(reg)
	    " yank visually selected text
	    silent exe 'norm! gv"'.reg.'y'
	    let value = getreg(reg)
	    " restore reg
	    call setreg(reg, reg_save, reg_type)
	    return value
	endfunction
	vnoremap <leader>ll :<c-u>execute("FzfBLines ") . GetSelected()<cr>
	vnoremap <leader>lL :<c-u>execute("FzfLines ") . GetSelected()<cr>
	vnoremap <leader>la :<c-u>execute("FzfAg ") . GetSelected()<cr>
	" map <leader>b :FzfBuffers<cr>
	map <leader>b :FzfHistory<cr>
	map <leader>lc :FzfCommits<cr>
	map <leader>lC :FzfBCommits<cr>
	map <leader>CA :FzfCommands<cr>
	nmap <leader>ca :FzfCommands<cr>
	nmap <leader><Space> :FzfCommands<cr>
	map <leader>ff :FzfFiles<cr>
	" nmap <tab> :FzfCommands<cr>
	map <leader>lf :FzfFiles<cr>
	map <leader>gf :FzfGFiles<cr>
	map <leader>lt :FzfFiletypes<cr>
	map <leader>w :FzfWindows<cr>
	command! -bang -nargs=? -complete=dir FzfFiles
		\ call fzf#vim#files(<q-args>, fzf#vim#with_preview({'options': ['--layout=reverse', '--info=inline']}), <bang>0)
	command! -bang -nargs=? -complete=dir FzfGFiles
		\ call fzf#vim#gitfiles(<q-args>, fzf#vim#with_preview({'options': ['--layout=reverse', '--info=inline']}), <bang>0)
	" command! -bang -nargs=? -complete=dir FzfFiles
	"     \ call fzf#vim#files(<q-args>, fzf#vim#with_preview(), <bang>0)
	" }}}
	Plug 'tpope/vim-fugitive' "{{{
	Plug 'tpope/vim-rhubarb'
	Plug 'tommcdo/vim-fubitive'
	" }}}
	" TODO: Find out why on-load tag does not work
	" Plug 'idanarye/vim-merginal', {'on': 'MerginalToggle'} "{{{
	Plug 'idanarye/vim-merginal' "{{{
	map <leader>gm :MerginalToggle<cr>
	map <leader>y :MerginalToggle<cr>
	"}}}
	" HELP: Find out why the screwed up map works and the other one NOT!
	" nmap <leader>gd :Gvdiff<cr><c-w>l
	nmap <silent> <leader>gd :TagbarClose<cr>:Gvdiff<cr>:ERROR<cr>:set nofoldendable<cr>:wincmd l<cr>
	nmap <leader>gD :Gdelete<cr>:ERROR<cr>:wincmd L<cr>
	nmap <leader>gc :tabnew<cr>:Gcommit --verbose<cr>:only<cr>
	nmap <leader>gC :tabnew<cr>:Gcommit --verbose --amend<cr>:only<cr>
	nmap <leader>gx dp:wincmd h<cr>:update<cr>:wincmd l<cr>
	nmap <leader>gs :tabnew<cr>:Gstatus<cr>o
	nmap <leader>gb :Gblame<cr>
	nmap <leader>gB vap:Gbrowse<cr>
	vmap <leader>gB :Gbrowse<cr>
	nmap <leader>gp :Gpush<cr>
	nmap <leader>gw :Gwrite<cr>
	nmap <leader>gg :Git
	nmap <leader>gl :silent! Glog --<cr>:bot copen<cr>
	" TODO: Find out why this end up in the left window
	autocmd vimrc FileType gitcommit,fugitive map <buffer> ; odvlzi
	autocmd vimrc FileType fugitive map <buffer> D =
	autocmd vimrc FileType fugitive map <buffer> e =
	autocmd vimrc FileType fugitive map <buffer> dd =
	autocmd vimrc FileType gitcommit map <buffer> <leader>C :Gcommit\ --verbose<cr>
	autocmd vimrc FileType gitrebase map <buffer> ; :execute("only\|bo Gvsplit " . substitute(getline('.'), '^\k\+\s\(\x\+\)\s.*$','\1','g'))<cr>
	" autocmd vimrc FileType gitcommit map <buffer> ; :only<cr>dv
	" Enable spell checking for commit messages
	autocmd vimrc BufNewFile,BufReadPost *.git/COMMIT_EDITMSG setfiletype gitcommit | set spell | silent! nunmap ;
	autocmd vimrc BufReadPost /tmp/cvs*,svn-commit.tmp*,*hg-editor* setlocal spell
	" }}}
	Plug 'gregsexton/gitv'
	Plug 'junegunn/gv.vim' "{{{
	command! Gvv GV --all
	command! Gvvv GV --all --date-order
	" nmap <leader>gv :GV --all<cr>
	nmap <leader>gv :GV<cr>
	nmap <leader>gV :GV!<cr>
	vmap Gv :GV!<cr>
	vmap GV :GV?<cr>
	autocmd vimrc FileType GV map <buffer> ; o
	autocmd vimrc FileType GV map <buffer> l ;
	autocmd vimrc FileType GV map <buffer>  O
	" }}}
	Plug 'AndrewRadev/splitjoin.vim'"{{{
	let g:splitjoin_quiet=0
	"}}}
	Plug 'inkarkat/vim-CompleteHelper' "{{{
	Plug 'inkarkat/vim-ingo-library'
	Plug 'vim-scripts/PrevInsertComplete'
	Plug 'vim-scripts/MotionComplete'
	Plug 'vim-scripts/BracketComplete'
	Plug 'vim-scripts/MultiWordComplete'
	Plug 'inkarkat/vim-WORDComplete'
	Plug 'https://github.com/vim-scripts/AlphaComplete'
	Plug 'https://github.com/inkarkat/vim-PatternComplete'
	"}}}
	" Plug 'inkarkat/vim-session'"{{{
	" let g:session_autoload = 'yes'
	" let g:session_default_to_last = 'yes'
	" let g:session_autosave = 'yes'
	" let g:session_autosave_to = 'yes'
	" let g:session_autosave_periodic = 'yes'
	" let g:session_autosave_periodic = 'yes'
	" let g:session_persist_globals = ['&makeprg', '&makeef']
	" -save session periodically
	" -check vim-obsession
	" autocmd vimrc VimLeave * mksession! ~/.vim/lastsession
	" TODO: Use fnamemodify() or fnameescape()
	" let &viminfo="'50,<1000,s100,:9999,/9999,n~/.vim/viminfo/" . substitute($PWD, "/\| ", "_", "g")
	" let &viminfo="'50,<1000,s100,:9999,/9999,n~/.vim/viminfo/" . substitute(substitute($PWD, "/", "_", "g"), " ", "_", "g")
	"}}}
	Plug 'airblade/vim-gitgutter', {'on': 'GitGutterToggle'} "{{{
	let g:gitgutter_highlight_lines = 0
	let g:gitgutter_override_sign_column_highlight = 1
	highlight clear SignColumn
	highlight GitGutterAdd ctermbg=black
	map <leader>gG :GitGutterToggle<cr>
	" }}}
	Plug 'junegunn/vim-github-dashboard' "{{{
	let g:github_dashboard = { 'username': 'dsh2', 'password': $GHD_GITHUB_TOKEN }
	" }}}
	Plug 'Shougo/unite.vim', {'on': 'Unite'} "{{{
	nnoremap <silent> <leader>lb :<C-u>Unite buffer file_mru<CR>
	nnoremap <silent> <F3> :Unite buffer<cr>
	autocmd vimrc FileType unite map <buffer> <F3> q
	Plug 'Shougo/vimproc.vim', { 'do': 'make' }
	Plug 'Shougo/neomru.vim'
	let g:neomru#time_format='%F %T '
	let g:neomru#update_interval=60
	"}}}
	Plug 'AndrewRadev/linediff.vim' "{{{
	nmap <leader>ld :Linediff<cr>
	nmap <leader>lD :LinediffReset<cr>
	" }}}
	Plug 'will133/vim-dirdiff', { 'on': 'DirDiff'} "{{{
	" let g:DirDiffExcludes = "*.class,*.exe,.*.swp,*.so,*.img"
	" Plug 'rickhowe/diffchar.vim'
	" let g:DiffUnit = 'Word1'
	" let g:DiffColors = 0 " fixed color
	" " let g:DiffColors = 1 " 4 colors in fixed order
	" Plug 'rickhowe/spotdiff.vim'
	" noremap <leader>ldt :Diffthis<CR>
	" noremap <leader>ldr :Diffoff!<CR>
	" noremap <leader>ldo :Diffoff!<CR>
	" " }}}
	Plug 'hari-rangarajan/CCTree' "{{{
	" TODO:
	" let g:CCTreeCscopeDb = ".cscope/out"
	" autocmd vimrc BufNewFile,BufReadPost CCTree-View nnoremap q :echo q
	let g:CCTreeCscopeDb = "cscope.out"
	let g:CCTreeDisplayMode = 1
	let g:CCTreeHilightCallTree=1
	let g:CCTreeMinVisibleDepth = 3
	let g:CCTreeOrientation = "topleft"
	let g:CCTreeRecursiveDepth = 1
	let g:CCTreeUseUTF8Symbols = 1
	let g:CCTreeWindowWidth = -1
	let g:CCTreeDbFileMaxSize = 40000000
	let g:CCTreeKeyHilightTree = '<C-h>'        " Static highlighting
	let g:CCTreeKeyDepthPlus = '='
	let g:CCTreeKeyDepthMinus = '-'
	" -re-use tree control code for uftrace, etc
	" map ; to preview
	" -add command to load db to cscope load event
	" -use async-run or similar for that
	" }}}
	Plug 'Ilink/cscope-quickfix' "{{{
	set cscopepathcomp=2
	" set cscopeprg=/opt/local/bin/cscope
	set cscopetag
	set cscopequickfix=s-,c-,d-,i-,t-,e-
	set cscoperelative
	if filereadable("cscope.out")
	silent! cscope add cscope.out
	" CCTreeLoadDB cscope.out
	endif
	set cscopeverbose
	function! QfLlNext()
		windo if &l:buftype == "quickfix" | silent! cnext | if &l:buftype == "location" | silent! lnext | endif | endif
	endfunction
	nnoremap <C-n> :call QfLlNext()<cr>
	function! QfLlPrevious()
		windo if &l:buftype == "quickfix" | silent! cprevious | if &l:buftype == "location" | silent! lprevious | endif | endif
	endfunction
	nnoremap <C-p> :call QfLlPrevious()<cr>
	" FIXME: does not work :(
	autocmd vimrc FileType qf set norelativenumber
	autocmd vimrc FileType qf wincmd J
	"}}}
	" Plug 'text objects' {{{
	Plug 'kana/vim-textobj-user'
	Plug 'kana/vim-textobj-indent'
	Plug 'kana/vim-textobj-fold'
	let g:textobj_function_no_default_key_mappings = 1
	xmap aF <Plug>(textobj-function-a)
	vmap aF <Plug>(textobj-function-a)
	xmap iF <Plug>(textobj-function-i)
	vmap iF <Plug>(textobj-function-i)
	Plug 'kana/vim-textobj-function'
	Plug 'kana/vim-textobj-line'
	Plug 'kana/vim-textobj-entire'
	Plug 'kana/vim-textobj-lastpat'
	" Plug 'paulhybryant/vim-textobj-path'
	Plug 'coderifous/textobj-word-column.vim'
	Plug 'vim-scripts/argtextobj.vim'
	Plug 'thinca/vim-textobj-between'
	Plug 'adriaanzon/vim-textobj-matchit'
	xmap a%  <Plug>(textobj-matchit-a)
	omap a%  <Plug>(textobj-matchit-a)
	xmap i%  <Plug>(textobj-matchit-i)
	omap i%  <Plug>(textobj-matchit-i)
	Plug 'beloglazov/vim-textobj-quotes'
	xmap q iq
	omap q iq
	" Plug 'rhysd/vim-textobj-continuous-line'
	Plug 'kana/vim-textobj-datetime'
	Plug 'vim-utils/vim-space'
	" Plug 'rsrchboy/vim-textobj-heredocs'
	Plug 'Julian/vim-textobj-variable-segment'
	Plug 'whatyouhide/vim-textobj-xmlattr'
	" }}}
	Plug 'gcmt/taboo.vim' "{{{
	let g:taboo_tab_format = "[%N|%f(%W)%m] "
	" let g:taboo_tab_format = "[%N|%a/%f(%W)%m] "
	let g:taboo_renamed_tab_format ="[%N|%l%m(%W)] "
	" TODO: Make this work
	let g:taboo_unnamed_tab_label = '%a'
	nmap <leader>tR :TabooReset<cr>
	nmap <leader>tr :TabooRename
	nmap <leader>tn :TabooOpen
	nmap <leader>, gT
	nmap <leader>. gt
	map <c-1> gT
	map <c-2> gt
	" TODO: Make this indeed pwd, same for TabooOpen
	nmap <leader>N :tabnew<cr>:pwd<cr>
	nmap <leader>tn :$tabnew<cr>
	nmap <leader>tc :tabclose<cr>
	" }}}
	Plug 'francoiscabrol/ranger.vim', {'on': 'Ranger'}"{{{
	map <leader>ff :Ranger<cr>
	"}}}
	Plug 'simnalamburt/vim-mundo', {'on': 'MundoToggle'} "{{{
	nnoremap <F4> :MundoToggle<cr>
	let g:mundo_preview_bottom=1
	let g:mundo_verbose_graph=0

	let g:mundo_mappings = {
		\ '<CR>': 'preview',
		\ 'o': 'preview',
		\ 'j': 'move_older',
		\ 'k': 'move_newer',
		\ '<down>': 'move_older',
		\ '<up>': 'move_newer',
		\ 'J': 'move_older_write',
		\ 'K': 'move_newer_write',
		\ 'gg': 'move_top',
		\ 'G': 'move_bottom',
		\ 'P': 'play_to',
		\ 'd': 'diff',
		\ 'i': 'toggle_inline',
		\ '/': 'search',
		\ 'n': 'next_match',
		\ 'N': 'previous_match',
		\ 'p': 'diff_current_buffer',
		\ 'r': 'diff',
		\ '?': 'toggle_help',
		\ 'q': 'quit',
		\ '<2-LeftMouse>': 'mouse_click' }

	autocmd vimrc FileType Mundo nnoremap <buffer> ; <cr>l
	" }}}
	" Plug 'mbbill/undotree', {'on': 'UndotreeToggle'} "{{{
	" let g:undotree_WindowLayout = 2
	" let g:undotree_SetFocusWhenToggle = 1
	" " let g:undotree_DiffCommand = "diff -y"
	" let g:undotree_DiffCommand = "diff -U 5"
	" let g:undotree_DiffpanelHeight = 25
	" let g:undotree_TreeNodeShape = "o"
	" nnoremap <F4> :UndotreeToggle<cr>
	" autocmd vimrc FileType undotree nmap <buffer> ; <cr>
	" " }}}
	Plug 'vim-pandoc/vim-pandoc', {'for': ['pandoc', 'markdown']} "{{{
	Plug 'vim-pandoc/vim-pandoc-syntax'
	autocmd vimrc FileType markdown set wrap
	let g:pandoc#folding#level = 9
	" let g:pandoc#formatting#mode = 'hA' " hard wraps, auto smart
	let g:pandoc#formatting#mode = 'h' " soft wraps
	" let g:pandoc#formatting#mode = 's' " soft wraps
	" let g:pandoc#formatting#mode = 'a' " autoformatting
	" let g:pandoc#formatting#mode = 'A' " smart autoformatting (watch out for source code)
	let g:pandoc#formatting#textwidth=79
	let g:pandoc#modules#disabled = ["chdir"]
	let g:pandoc#formatting#extra_equalprg="--atx-headers"
	" let g:pandoc#formatting#equalprg= "pandoc -t markdown --atx-headers --columns " . g:pandoc#formatting#textwidth
	let g:pandoc#formatting#smart_autoformat_on_cursormoved = 0
	"}}}
	Plug 'chrisbra/csv.vim', {'for': 'csv' } "{{{
	" hi CSVColumnEven term=bold ctermbg=4 guibg=DarkBlue
	" hi CSVColumnOdd  term=bold ctermbg=5 guibg=DarkMagenta
	" hi link CSVColumnOdd MoreMsg
	" hi link CSVColumnEven Question
	" autocmd vimrc Filetype csv hi CSVColumnEven ctermbg=4
	" autocmd vimrc Filetype csv hi CSVColumnOdd  ctermbg=5
	let g:csv_no_column_highlight = 0
	let b:csv_arrange_align = 'l*'
	let g:csv_arrange_align = 'l*'
	let g:csv_autocmd_arrange = 1
	" TODO: If readonly set nofile?
	map <leader>CT :setlocal modifiable<cr>:setlocal filetype=csv<cr>let g:csv_delim="\t"<cr>ggVG:ArrangeColumn!<cr>let b:csv_headerline = 0<cr>
	map <leader>C; :setlocal modifiable<cr>:setlocal filetype=csv<cr>let g:csv_delim=";"<cr>ggVG:ArrangeColumn!<cr>let b:csv_headerline = 0<cr>
	" map <leader>C, :setlocal modifiable<cr>:setlocal filetype=csv<cr>let g:csv_delim=','<cr>ggVG:ArrangeColumn!<cr>let b:csv_headerline = 0<cr>
	map <leader>C, :setlocal modifiable<cr>:setlocal filetype=csv<cr>:NewDelimiter ,<cr>ggVGG:ArrangeColumn!<cr>let b:csv_headerline = 0<cr>
	map <leader>CC :setlocal modifiable<cr>:setlocal filetype=csv<cr>ggVG:ArrangeColumn!<cr>let b:csv_headerline = 0<cr>
	map <leader>CS :set noreadonly<cr>:setlocal modifiable<cr>:%s/\s\{1,\}/,/<cr>:let @/=""<cr>:setlocal filetype=csv<cr>ggVG:ArrangeColumn!<cr>let g:csv_headerline=0<cr>0
	autocmd vimrc BufRead,BufNewFile *.csv set filetype=csv
	" TODO: Add toggle reverse order support
	autocmd vimrc FileType csv map <buffer> <leader>cs :Sort<cr>
	autocmd vimrc FileType csv map <buffer> <leader>c/ :CSVSearchInColumn
	autocmd vimrc FileType csv map <buffer> <leader>ca :Analyze<cr>
	" TODO: Add maps for
	" -Toggle aligns (left, right, etc.)
	" -Number types (hex, etc.)
	" }}}
	Plug 'kelwin/vim-smali', {'for': 'smali'} "{{{
	"Plug 'alderz/smali-vim'
	autocmd vimrc BufRead *.smali set filetype=smali
	" }}}
	Plug 'xolox/vim-lua-ftplugin', {'for': 'lua'} "{{{
	Plug 'xolox/vim-misc'
	" }}}
	Plug 'elzr/vim-json', {'for': 'json'}  "{{{
	autocmd vimrc FileType json set conceallevel=0
	let g:vim_json_syntax_concealcursor = 0
	" }}}
	Plug 'scrooloose/nerdtree' "{{{
	Plug 'Xuyuanp/nerdtree-git-plugin'
	" let g:NERDTreeShowIgnoredStatus = 1
	let g:NERDTreeGitStatusShowIgnored = 1
	let g:NERDTreeGitStatusIndicatorMapCustom = {
		\ "Modified"  : "M",
		\ "Staged"    : "+",
		\ "Untracked" : "N",
		\ "Renamed"   : "R",
		\ "Unmerged"  : "<",
		\ "Deleted"   : "D",
		\ "Dirty"     : ">",
		\ "Clean"     : "C",
		\ "Ignored"   : 'I',
		\ "Unknown"   : "?"
		\ }
	let NERDTreeIgnore = ['\~$[[file]]', '\.pyc$[[file]]']
	let NERDTreeShowHidden = 1
	let NERDTreeWinSize = 46
	let NERDTreeMinimalUI = 1
	autocmd vimrc FileType nerdtree map <buffer> l oj^
	"autocmd vimrc FileType nerdtree map <buffer> O mo
	autocmd vimrc FileType nerdtree map <buffer> h x^
	autocmd vimrc FileType nerdtree map <buffer> ; go
	autocmd vimrc FileType nerdtree map <buffer> <F2> :NERDTreeClose<cr>
	nnoremap <F2> :NERDTreeFind<cr>
	" }}}
	Plug 'tyru/open-browser.vim' "{{{
	" let g:netrw_nogx = 1 " disable netrw's gx mapping.
	nmap gx <Plug>(openbrowser-smart-search)
	vmap gx <Plug>(openbrowser-smart-search)
	command! OpenBrowserCurrent execute "OpenBrowser" "file://" . expand('%:p:gs?\\?/?')
	map gX OpenBrowserCurrent
	" let g:openbrowser_browser_commands = [
	"         \   {'name': 'google-chome',
	"         \    'args': ['start', '{browser}', '{uri}']}
	"         \]
	"}}}
	Plug 'dsh2/tagbar' " ", {'on': 'TagbarToggle'}  
	Plug 'hushicai/tagbar-javascript.vim' " {{{
	let g:tagbar_autoclose = 0
	" TODO: Add support for percent instead of number of characters
	let g:tagbar_width = 40
	let g:tagbar_zoomwidth = 0
	let g:tagbar_compact = 1
	let g:tagbar_indent = 1
	let g:tagbar_show_linenumbers = 0
	let g:tagbar_autofocus = 0
	let g:tagbar_hide_nonpublic = 0
	let g:tagbar_autoshowtag = 1
	let g:tagbar_autopreview = 0
	map <leader>tt :silent! TagbarToggle<cr>
	autocmd vimrc VimEnter * nested :silent! call tagbar#autoopen(1)
	" autocmd vimrc VimEnter * nested :silent! TagbarToggle
	autocmd vimrc FileType tagbar map <buffer> ; p
	autocmd vimrc FileType tagbar map <buffer> A x
	autocmd vimrc FileType tagbar map <buffer> l za
	autocmd vimrc FileType tagbar map <buffer> h za
	" }}}
	Plug 'jeetsukumaran/vim-markology' "{{{
	let g:markology_enable = 0
	let g:markology_textlower = "\t>"
	let g:markology_textupper = "\t}"
	let g:markology_textother = "\t:"
	let g:markology_hlline_lower = 0
	let g:markology_hlline_upper = 0
	let g:markology_hlline_other = 0
	highlight MarkologyHLl ctermfg=Cyan ctermbg=black
	highlight MarkologyHLu ctermfg=Cyan ctermbg=black
	highlight MarkologyHLo ctermfg=Cyan ctermbg=black
	" }}}
	Plug 'brookhong/ag.vim', {'on': 'Ag'}  "{{{
	" map <leader>a :Ag! \\b<cword\\b><CR>
	" map <leader>a :Ag! <cword><CR>
	map <leader>a :Rg <cword><CR>
	map <leader><leader>a :Rg --no-ignore <cword><CR>
	vnoremap <leader>a :<c-u>execute("Ag -- ") . GetSelected()<cr>
	" }}}
	Plug 'szw/vim-maximizer', {'on': 'MaximizerToggle'}  "{{{
	nnoremap <c-w>m :MaximizerToggle<cr>
	nnoremap <c-w><c-m> :MaximizerToggle<cr>
	"}}}
	Plug 'bling/vim-airline' "{{{
	Plug 'vim-airline/vim-airline-themes'
	Plug 'ompugao/vim-airline-cwd'
	let g:airline#extensions#branch#enabled = 0
	let g:airline#extensions#branch#empty_message = '(no branch)'
	let g:airline#extensions#ale#enabled = 1
	let g:airline#extensions#syntastic#enabled = 1
	let g:airline#extensions#capslock#enabled = 1
	let g:airline#extensions#whitespace#enabled = 0
	let g:airline#extensions#csv#enabled = 1
	let g:airline#extensions#nerdtree_status = 1
	let g:airline#extensions#tagbar#enabled = 1
	let g:airline_detect_paste=0
	let g:airline_detect_modified=1
	let g:airline_detect_spelllang=1
	let g:airline#parts#ffenc#skip_expected_string='utf-8[unix]'
	" }}}
	Plug 'tpope/vim-jdaddy'
	Plug 'tpope/vim-dispatch' "{{{
	" map <leader>M :update<cr>:Make<cr>:copen<cr>/error:<cr>n
	map <leader>m :update<cr>:Make<cr>:checktime<cr>
	" }}}
	Plug 'sickill/vim-pasta' "{{{
	" let g:pasta_disabled_filetypes = ['python', 'coffee', 'yaml', 'tagbar']
	let g:pasta_disabled_filetypes = ['qf', 'tagbar', 'netrw']
	"}}}
	Plug 'powerman/vim-plugin-AnsiEsc', {'on': 'AnsiEsc'} "{{{
	map <leader>W :AnsiEsc<cr>
	" Remove ansi escape sequence
	if executable("strip-ansi")
		function! StripAnsi()
			:silent %!strip-ansi
			echo "StripAnsi: called strip-ansi-cli"
		endfunction
	else
		function! StripAnsi()
			let @/='\v%x1b[(\d{0,3})(;\d{1,3}){0,5}(m|K)'
			silent! execute "%s:::"
			echo "StripAnsi: search-and-replace"
		endfunction
	endif
	command! StripAnsi call StripAnsi()
	map <leader>Q :StripAnsi<cr>
	"}}}
	Plug 'romgrk/winteract.vim', {'on': 'InteractiveWindow'} "{{{
	nmap gw :InteractiveWindow<CR>
	"}}}
	Plug 'Shougo/vinarise.vim', {'on': 'Vinarise'} "{{{
	map <leader>V :Vinarise<cr>
	"}}}
	Plug 'nathanaelkane/vim-indent-guides', {'on': 'IndentGuidesToggle'} "{{{
	let g:indent_guides_guide_size = 1
	" let g:indent_guides_start_level = 2
	"}}}
	Plug 'junegunn/vim-peekaboo' "{{{
	let g:peekaboo_window = 'vertical botright 51new'
	let g:peekaboo_delay = 0
	let g:peekaboo_compact = 0
	"}}}
	Plug 'Chiel92/vim-autoformat', {'on': 'Autoformat'} "{{{
	" let g:formatdef_my_custom_json = '"jq -s"'
	let g:formatdef_my_custom_json = '"jq"'
	let g:formatdef_my_custom_sh = '"shfmt -i 0 -bn -ci -sr"'
	let g:formatters_sh = ['my_custom_sh']
	let g:formatters_json = ['my_custom_json']
	let g:formatdef_my_custom_sql = '"sqlformat -k lower -i lower  --indent_width 4  -"'
	let g:formatters_sql = ['my_custom_sql']
	let g:autoformat_verbosemode=1
	" TODO: try to understand why resetting syn is necessary
	map <leader>A :Autoformat \| syn off \| syn on \" set foldlevel=1<cr>
	"}}}
	Plug 'tpope/vim-commentary' "{{{
	autocmd vimrc BufNewFile,BufReadPost authorized_keys,known_hosts,*.conf setlocal commentstring=#\ %s
	" autocmd vimrc FileType asn setlocal commentstring=--\ %s
	autocmd vimrc FileType config,crontab,expect,exports,dosini,sshconfig,sshdconfig,sh,systemd,i3config,jq,resolv,gitconfig setlocal commentstring=#\ %s
	autocmd vimrc FileType asn,sql setlocal commentstring=--\ %s
	nmap gcC yygccp
	"}}}
	Plug 'pseewald/vim-anyfold'
	Plug 'dsh2/diff-fold.vim', {'for': 'diff'} "{{{
	autocmd vimrc FileType diff map <buffer> <leader>d <Plug>DiffFoldNav
	"}}}
	Plug 'skywind3000/asyncrun.vim', {'on': 'AsyncRun'} "{{{
	" map <leader>B :AsyncRun binwalk %<cr>
	autocmd vimrc User AsyncRunStart call asyncrun#quickfix_toggle(8, 1)
	autocmd vimrc BufReadPost .\\\{0,1\}vimrc,vimrc.nvim,init.vim,nvimrc,.nvimrc nnoremap <buffer> <silent> <cr> 0f/lgf
	"}}}
	Plug 'atimholt/spiffy_foldtext' "{{{
	" TODO: Add more preview text, squece as much content as possible?
	let g:SpiffyFoldtext_format='%c{-} %<%f{-}| %4n lines |-%l{--}'
	"}}}
	Plug 't9md/vim-quickhl'
	Plug 'dsh2/HiCursorWords' "{{{
	let g:HiCursorWords_delay = 10
	let g:HiCursorWords_hiGroupRegexp = ''
	" let g:HiCursorWords_style='term=reverse cterm=reverse gui=reverse'
	" let g:HiCursorWords_linkStyle='ErrorMsg'
	" let g:HiCursorWords_linkStyle='IncSearch'
	let g:HiCursorWords_linkStyle='MatchParen'
	" let g:HiCursorWords_linkStyle='VisualNOS'
	" let g:HiCursorWords_debugEchoHiName = 1
	let g:HiCursorWords_debugEchoHiName = 0
	" }}}
	Plug 'flatcap/vim-keyword' "{{{
	" TODO: Make this work
	map <leader>k <plug>KeywordToggle
	map <leader>K :call keyword#KeywordClear()<cr>
	let g:keyword_group = 'keyword_group'
	" let g:keyword_highlight = 'ctermbg=darkred cterm=underline'
	let g:keyword_highlight = 'ctermbg=darkred'
	"}}}
	Plug 'vim-scripts/LargeFile'"{{{
	let g:LargeFile = 50
	set synmaxcol=2048"}}}
	Plug 'w0rp/ale'  "{{{
	autocmd vimrc FileType cpp nmap <leader><leader> :ALEGoToDefinitionInVSplit<cr>
	autocmd vimrc FileType cpp nmap <leader> :ALEGoToDefinitionInSplit<cr>
	" autocmd vimrc FileType cpp nmap  :ALEGoToDefinition<cr>
	autocmd vimrc FileType cpp nmap x :ALEFindReferences<cr>
	autocmd vimrc FileType cpp nmap <leader>~ :ALEHover<cr>
	let g:airline#extensions#ale#enabled = 1
	let g:ale_set_loclist = 1
	let g:ale_set_quickfix = 0
	let g:ale_open_list = 0
	let g:ale_keep_list_window_open = 1
	let g:ale_fix_on_save = 1
	let g:ale_lint_on_enter = 1
	" let g:ale_lint_on_text_changed = "never"
	let g:ale_lint_on_text_changed = "always"
	" let g:ale_open_list = "never"
	let g:ale_open_list = "always"
	" }}}
	Plug 'machakann/vim-highlightedyank'"{{{
	let g:highlightedyank_highlight_duration = 333
	if !exists('##TextYankPost')
	    map y <Plug>(highlightedyank)
	endif
	"}}}
	Plug 'derekwyatt/vim-fswitch'"{{{
	autocmd vimrc BufEnter *.h let b:fswitchdst = 'cc' | let b:fswitchlocs = '../inc'
	autocmd vimrc BufEnter *.cc let b:fswitchdst = 'h' | let b:fswitchlocs = '../inc'
	let g:fsnonewfiles="off"
	nmap <silent> <Leader>of :FSHere<cr>
	nmap <silent> cof :FSHere<cr>
	"}}}
	" Plug tmux {{{
	Plug 'tmux-plugins/vim-tmux', {'for': 'tmux'}
	autocmd vimrc BufRead tmux.conf set filetype=tmux
	Plug 'tmux-plugins/vim-tmux-focus-events'
	Plug 'wellle/tmux-complete.vim'
	let g:tmuxcomplete#trigger = 'omnifunc'
	"}}}
	" Plug colorschemes {{{
	Plug 'machakann/vim-colorscheme-reki'
	Plug 'machakann/vim-colorscheme-tatami'
	Plug 'morhetz/gruvbox'
	Plug 'rhysd/vim-color-spring-night'
	Plug 'Lokaltog/vim-distinguished'
	Plug 'altercation/vim-colors-solarized'
	let g:solarized_termcolors=256
	let g:solarized_contrast="normal"
	let g:solarized_visibility="normal"
	let g:solarized_diffmode="high"
	Plug 'chriskempson/vim-tomorrow-theme'
	Plug 'jnurmine/Zenburn'
	Plug 'junegunn/seoul256.vim'
	Plug 'nanotech/jellybeans.vim'
	Plug 'pwntester/VimCobaltColourScheme'
	Plug 'pwntester/cobalt2.vim'
	Plug 'reedes/vim-colors-pencil'
	Plug 'tomasr/molokai'
	Plug 'xolox/vim-colorscheme-switcher'
	" }}}
	Plug 'mogelbrod/vim-jsonpath'" {{{
	let g:jsonpath_register = '+'
	autocmd vimrc FileType json noremap <buffer> <silent> <leader>p :call jsonpath#echo()<CR>
	autocmd vimrc FileType json noremap <buffer> <silent> <leader>g :call jsonpath#goto()<CR>
	"}}}
	Plug 'matze/vim-ini-fold' "{{{
	autocmd vimrc BufNewFile,BufReadPost wg*\.conf,*.nmconnection,*/NetworkManager/system-connections/* setfiletype dosini"
	"}}}
	Plug 'machakann/vim-highlightedundo' "{{{
	let g:highlightedundo#highlight_mode=2
	nmap u <Plug>(highlightedundo-undo)
	nmap U <Plug>(highlightedundo-redo)
	nmap g- <Plug>(highlightedundo-gminus)
	nmap g+ <Plug>(highlightedundo-gplus)
	"}}}
	let g:go_version_warning = 0
	Plug 'fatih/vim-go'"{{{
	let g:go_version_warning = 0
	let g:go_def_mode='gopls'
	let g:go_info_mode='gopls'
	" run :GoBuild or :GoTestCompile based on the go file
	function! s:build_go_files()
		let l:file = expand('%')
		if l:file =~# '^\f\+_test\.go$'
			call go#test#Test(0, 1)
		elseif l:file =~# '^\f\+\.go$'
			call go#cmd#Build(0)
		endif
	endfunction

	autocmd vimrc FileType go nmap <a-s-k> :GoDocBrowser<cr>
	autocmd vimrc FileType go nmap <f9> :GoDebugBreakpoint<cr>
	autocmd vimrc FileType go nmap <leader>B :GoBuild<cr>
	autocmd vimrc FileType go nmap <a-s-r> :GoDebugStart<cr>
	autocmd vimrc FileType go nmap <c-a-s-r> :GoDebugStop<cr>
	autocmd vimrc FileType go nmap <s-f10> :GoDebugNext<cr>
	autocmd vimrc FileType go nmap <s-f11> :GoDebugStep<cr>
	autocmd vimrc FileType go nmap <a-s-f11> :GoDebugStepOut<cr>
	autocmd vimrc FileType go nmap <leader>T :GoDecls<CR>
	autocmd vimrc FileType go nmap <leader>m :<C-u>call <SID>build_go_files()<CR>

	autocmd vimrc FileType go map <buffer> <leader>r :GoRun<cr>
	autocmd vimrc FileType go map <buffer> <leader>~ :GoDescribe<cr>
	autocmd vimrc FileType go nmap <c-space> :GoDescribe<CR>
	autocmd vimrc FileType go map <buffer> <s-f2> :GoRename<cr>
	autocmd vimrc FileType go map <buffer> <c-\>s :GoReferrers<cr>
	autocmd vimrc FileType go map <buffer> <leader><c-]> :<C-U>call go#def#Jump("vert", 0)<CR>
	" let g:go_debug = [ 'shell-commands', 'debugger-state', 'debugger-commands', 'lsp' ]
	" let g:go_debug = [ 'lsp' ]
	let g:go_info_mode = 'guru'
	let g:go_fmt_command = "goimports"
	" }}}
	Plug 'davidhalter/jedi-vim', {'for': 'python'} "{{{

	let g:jedi#goto_stubs_command = ''
	let g:jedi#auto_close_doc = 0
	let g:jedi#completions_command = "<C-space>"
	let g:jedi#goto_command = "<c-]>"
	let g:jedi#show_call_signatures = 2
	let g:jedi#show_call_signatures_delay = 0
	let g:jedi#smart_auto_mappings = 1
	let g:jedi#squelch_py_warning = 1
	" let g:jedi#use_splits_not_buffers = ""
	" let g:jedi#use_tabs_not_buffers = 1
	let g:jedi#use_splits_not_buffers = "left"
	let g:jedi#use_tabs_not_buffers = 0
	let g:jedi#completions_enabled = 0  " favor deoplete-jedi

	" let g:jedi#force_py_version = 3.4
	Plug 'tmhedberg/SimpylFold', {'for': 'python'}
	" Plug 'nvie/vim-flake8'
	" Plug 'xolox/vim-pyref'
	" }}}
	" Plug 'dsh2/vim-man' " TODO: { 'dir': '~/.vim-man', 'do': 'git pull orig' } " {{{
	" augroup manlaunchtoc
	"     autocmd!
	"     if has('nvim')
	"	autocmd FileType man
	"		    \ call man#show_toc() |
	"		    \ setlocal laststatus=0 nonumber norelativenumber |
	"		    \ nnoremap <buffer> l <Enter> |
	"		    \ wincmd H |
	"		    \ vert resize 35 |
	"		    \ wincmd p
	"     endif
	" augroup end
	" }}}
	Plug 'Shougo/echodoc.vim'"{{{
	let g:echodoc_enable_at_startup = 1
	" let g:echodoc#type = 'virtual'
	" let g:echodoc#type = 'echo'
	let g:echodoc#type = 'signature'"}}}
	Plug 'sakhnik/nvim-gdb'
	" Plug rest... {{{
	Plug 'terryma/vim-expand-region'
	Plug 'christianrondeau/vim-base64'
	Plug 'mhinz/vim-rfc'
	Plug 'nakal/vim-smarttabs'
	Plug 'bfrg/vim-cpp-modern'
	Plug 'tommcdo/vim-exchange'
	Plug 'robbles/logstash.vim'
	Plug 'junegunn/vim-easy-align' "{{{
	map <leader>EA :EasyAlign
	xmap ga <Plug>(EasyAlign)
	nmap ga <Plug>(EasyAlign)" }}}
	
	Plug 'actionshrimp/vim-xpath'
	Plug 'tpope/vim-abolish'
	Plug 'nfnty/vim-nftables'
	Plug 'jremmen/vim-ripgrep'
	Plug 'tpope/vim-endwise'
	" Plug 'tpope/vim-rails'
	Plug 'pedrohdz/vim-yaml-folds'
	Plug 'tpope/vim-bundler'
	Plug 'Quramy/tsuquyomi'
	Plug 'tommcdo/vim-exchange'
	Plug 'szw/vim-dict'
	Plug 'google/vim-searchindex'
	Plug 'tpope/vim-surround'
	Plug 'tpope/vim-repeat'
	Plug 'dsh2/vim-CtrlXA'
	Plug 'Valloric/vim-operator-highlight'
	Plug 'tmhedberg/matchit'
	Plug 'chrisbra/Colorizer'
	Plug 'chrisbra/Recover.vim'
	Plug 'StanAngeloff/php.vim'
	Plug 'rayburgemeestre/phpfolding.vim'
	Plug 'dsh2/vim-unimpaired'
	Plug 'christoomey/vim-sort-motion'
	Plug 'christoomey/vim-system-copy'
	Plug 'embear/vim-foldsearch'
	Plug 'ervandew/matchem'
	Plug 'junegunn/rainbow_parentheses.vim'
	Plug 'lzap/vim-selinux', {'for': 'te'}
	Plug 'maksimr/vim-yate', {'for': 'yate'}
	Plug 'mboughaba/i3config.vim', {'for': 'i3config'}
	Plug 'nelstrom/vim-visual-star-search'
	Plug 'tpope/vim-afterimage'
	" Plug 'tpope/vim-dadbod'
	Plug 'tpope/vim-eunuch'
	Plug 'tpope/vim-rsi'
	Plug 'tpope/vim-tbone'
	Plug 'tpope/vim-abolish'
	Plug 'vim-scripts/ReplaceWithRegister'
	Plug 'vim-scripts/VCard-syntax', {'for': 'vcard'}
	Plug 'vim-scripts/info.vim', {'on': 'Info'}
	Plug 'vim-scripts/renamer.vim', {'on': 'Renamer'}
	Plug 'wannesm/wmgraphviz.vim', {'for': 'dot'}
	Plug 'z0mbix/vim-shfmt', { 'for': 'sh' }
	Plug 'frioux/vim-regedit'
	"}}}
	Plug 'Shougo/deoplete.nvim' " {{{
	let g:deoplete#enable_at_startup = 0
	autocmd vimrc InsertEnter * call deoplete#enable()
	Plug 'Shougo/deoplete.nvim', { 'do': ':UpdateRemotePlugins' }
	Plug 'Shougo/neosnippet.vim'
	Plug 'Shougo/neosnippet-snippets'
	Plug 'Shougo/context_filetype.vim'
	" Plugin key-mappings.
	" Note: It must be "imap" and "smap".  It uses <Plug> mappings.
	inoremap <expr><tab>  pumvisible() ? "<Plug>(neosnippet_expand_or_jump)" : "\<tab>"
	snoremap <expr><tab>  pumvisible() ? "<Plug>(neosnippet_expand_or_jump)" : "\<tab>"
	xnoremap <expr><tab>  pumvisible() ? "<Plug>(neosnippet_expand_or_jump)" : "\<tab>"
	imap <C-k>     <Plug>(neosnippet_expand_or_jump)
	smap <C-k>     <Plug>(neosnippet_expand_or_jump)
	xmap <C-k>     <Plug>(neosnippet_expand_target)
	" SuperTab like snippets behavior.
	" Note: It must be "imap" and "smap".  It uses <Plug> mappings.
	imap <expr><TAB>
		\ pumvisible() ? "\<C-n>" :
		\ neosnippet#expandable_or_jumpable() ?
		\    "\<Plug>(neosnippet_expand_or_jump)" : "\<TAB>"
	smap <expr><TAB> neosnippet#expandable_or_jumpable() ?
		\ "\<Plug>(neosnippet_expand_or_jump)" : "\<TAB>"

	" For conceal markers.
	if has('conceal')
		set conceallevel=2 concealcursor=niv
	endif
	Plug 'Shougo/neoinclude.vim'
	Plug 'fszymanski/deoplete-emoji'
	Plug 'Shougo/neco-vim'
	Plug 'ujihisa/neco-look'
	Plug 'deoplete-plugins/deoplete-jedi'
	call plug#end()

	call deoplete#custom#option({
		\ 'auto_refresh_delay': 100,
		\ 'camel_case': v:true,
		\ 'smart_case': v:true,
		\ 'skip_multibyte': v:true,
		\ 'prev_completion_mode': 'filter',
		\ 'auto_preview': v:false,
		\ })
	" \ 'auto_preview': v:true,
	" \ 'prev_completion_mode': 'none',
	" inoremap <expr><c-j>  pumvisible() ? "\<c-n>" : "\<c-j>"
	" inoremap <expr><c-k>  pumvisible() ? "\<c-p>" : "\<c-k>"
	" inoremap <silent><expr> <tab>
	"       \ pumvisible() ? "\<C-n>" :
	"       \ <SID>check_back_space() ? "\<TAB>" :
	"       \ deoplete#manual_complete()
	" function! s:check_back_space() abort
	"   let col = col('.') - 1
	"   return !col || getline('.')[col - 1]  =~ '\s'
	" endfunction

	call deoplete#custom#var(
		\ 'around', {
		\ 'range_above': 15,
		\ 'range_below': 15,
		\ 'mark_above': '[â†‘]',
		\ 'mark_below': '[â†“]',
		\ 'mark_changes': '[*]',})
	call deoplete#custom#source('member', 'filetypes', [])
	call deoplete#custom#source('emoji', 'filetypes', [])
	call deoplete#custom#source('emoji', 'converters', ['converter_emoji'])
	call deoplete#custom#option('omni_patterns', { 'go': '[^. *\t]\.\w*' })
	"}}}
endif
"}}}
" Global options {{{
set autoindent
set autowrite
set backspace=indent,eol,start
" TODO: update to neovim
" set backupdir=~/.vim/backup/
set cmdheight=2
set cmdwinheight=10
set complete+=kt
" set completeopt=menuone,preview
set completeopt=menuone
set concealcursor=n
set conceallevel=0
set clipboard=unnamedplus
set diffopt=
" set diffopt=filler,context:4
" set dir=~/.vim/swo
set encoding=utf8
set exrc
set secure
let g:xml_syntax_folding=1
set foldmethod=syntax
" set foldlevelstart=99
" set foldopen=hor,mark,percent,quickfix,search,tag,undo
set foldopen=hor,search,quickfix,tag
set gdefault
set grepprg=grep\ -nH\ $*
set hidden
set history=9999
set hlsearch
set ignorecase
set incsearch
set isfname-==
set laststatus=2
set mouse=a
set mousefocus
set nobackup
set relativenumber
set nospell
" set nowrap
set wrap
set linebreak
set nowrapscan
set number
set previewheight=14
set ruler
au BufEnter,BufNew,OptionSet * if &diff | set scrolloff=10 | else | set scrolloff=99 | endif
set shellslash
set shiftwidth=4
set tabstop=4
set shortmess=filnxtToOI
set showbreak=â€º
set showcmd
set showfulltag
set showmatch
set sidescroll=15
set sidescrolloff=8
set dictionary+=/usr/share/dict/american-english
set smartcase
set smartindent
set smarttab
set statusline=%<%f%h%m%r%=%b\ 0x%B\ \ %l,%c%V\ %P
" Maybe better add this to a local vimrc for c-projects
" set tags+=$HOME/.usr.include.tags
set tags+=$HOME/.usr.include.tags
set title
set titleold=''
set titlestring=%t%(\ %M%)%(\ (%{expand(\"%:p:h\")})%)%(\ %a%)\ -\ %{v:servername}
set notimeout
set nottimeout
set ttimeoutlen=50
set undodir=~/.vim/undodir/
set nofoldenable
set undofile
set updatetime=500
" set virtualedit=all
set wildignore=*~,*.o,*.obj,*.aux
set wildmenu
set wildmode=list:longest,full
autocmd vimrc BufNewFile,BufReadPost Vagrantfile setfiletype ruby
autocmd vimrc BufNewFile,BufReadPost .clang-format setfiletype yaml
autocmd vimrc BufNewFile,BufReadPost *.run setfiletype expect
" }}}
" Mappings {{{
map <leader>Dd :set spelllang=de<cr>
map <leader><c-r> :update<cr>:source %<cr>
" gdb helper {{{

nmap <m-8> :bot split term://$SHELL<cr>i
" nmapemap <cr> i
" tnoremap <leader><c-k> ?@(gdb)
" tnoremap <c-k> ?@(gdb)

tnoremap <expr> <c-s-v> '<c-\><c-n>"'.nr2char(getchar()).'pi'
tnoremap <c-[> <c-\><c-n>

" nnoremap ,w :call TermDebugSendCommand('where')<CR>
nnoremap <m-s-r> :Stop<cr>
nnoremap <f9> :Break<cr>
nnoremap <leader>B :Break<cr>
nnoremap <s-f10> :Over<cr>
nnoremap <s-f11> :Step<cr>
nnoremap <c-s-f11> :Finish<cr>
" }}}
cabbr BB <buffer>
nmap <nowait> <leader>s :update<cr>
" nnoremap <c-s> :update<cr>
inoremap <c-s> <c-o>:update<cr><esc>
map <a-s> <c-o>:update<cr><esc>

map <c-s> :Redir let<cr>gsae:se ft=conf buftype=nofile<cr>:se ts=43<cr>:%s/^\S*\zs\s\+/\t/<cr>gg:setl nohlsearch<cr>:FzfBLines<cr>
nmap Q :cq<cr>
map <leader>S :syn off \| syn on \| se foldenable foldlevel=2<cr>
nmap <leader>J :StripAnsi<cr>:set ft=json<cr>:Autoformat<cr>:syn off \| syn on \| se foldenable foldlevel=2<cr>
nmap <leader>X :StripAnsi<cr>:set ft=xml<cr>:Autoformat<cr>
nmap <leader>Y :StripAnsi<cr>:set ft=yaml<cr>:Autoformat<cr>:syn off \| syn on \| se foldenable foldlevel=2<cr>
map  
map  :bnext<cr>
map <c-.> :bprev<cr>
" map <leader><c-l> :redraw!<cr>:echo "Redraw!"<cr>
nmap <leader>o :silent !open "%"<cr>
nmap <nowait> <leader>s :update<cr>
" TODO: PWD vs. CWD
" TODO: merge witih neovim rc files
" map <silent><leader>R :source ~/.config/nvim/init.vim \| if filereadable("./.vimrc") \| source ./.vimrc \|  endif<cr>
" TODO: source scriptname instead
map <silent><leader>R :update<cr>:source ~/.config/nvim/init.vim<cr>
nnoremap <cr> :nohlsearch<CR>/<BS><CR>
" prepend space on <c-space>?
" imap <NUL> <space>h
" imap <c-space> <space>h
imap <s-space> <space>h
nmap <leader>cc :cd ..<cr>:pwd<cr>
" TODO: Filter ansi escape sequences from filename when file not found
nnoremap gf gF
" nnoremap gF :tabedit <cfile><cr>
nnoremap gF :split <cfile><cr>
map <c-w>v <c-w>v<c-w>l
map <leader>DU :diffupdate<cr>
vmap DP :diffput<cr>
vmap DG :diffget<cr>
nmap <leader>DD :diffthis<CR>
nmap <leader>DO :diffoff<CR>
nmap <leader>DS :vertical diffsplit<CR>
" TODO: Clean this up...
nnoremap <leader>cd :execute ":lcd " . substitute(expand("%:p:h"), ' ', '\\ ', 'g')<cr>:pwd<cr>"<cr>
nnoremap <leader>cD :Gcd<cr>:pwd<cr>
nnoremap <leader>C :Gcd<cr>:pwd<cr>
nnoremap <leader>gcd :Gcd<cr>:pwd<cr>
nmap <c-q> :cq<cr>
nmap <leader>P :pwd<cr>
nmap zx za
nmap <leader>BD :bdelete!<cr>
nmap <leader>DW :Delete<cr>:echo "FILE DELETED."<cr>
" TODO: add toggle for this: coG?
function! ToggleLineBreakMode()
	if maparg("j", "n") == "gj"
		unmap j
		unmap k
		unmap gj
		unmap gk
		" unmap 0
		" unmap g0
		echo "NOT breaking lines on movement."
    else
		nnoremap gj j
		nnoremap gk k
		nnoremap j gj
		nnoremap k gk
		" nnoremap g0 0
		" nnoremap 0 g0
		echo "Breaking lines on movement."
    endif
endfunction
nmap coG :call ToggleLineBreakMode()<cr>
noremap zz :set scrolloff=99<cr>zz
" Delete all matching lines
vmap <silent> <leader>D g*:%g//d<cr>
nmap <silent> <leader>D v$g*:%g//d<cr>
" TODO
" -Add convert to hex/bin/etc.
" -Parse as data-uri
" -Encode/decode as base64, uu, etc.
" -ROT13
" -Disassem ARM/Intel
map <leader>d :echo strftime('%F  %T', expand("<cword>"))<cr>

" Split navigations
nnoremap <c-j> <c-w><c-j>
nnoremap <c-k> <c-w><c-k>
nnoremap <c-l> <c-w><c-l>
nnoremap <c-h> <c-w><c-h>

function! YankUp(string)
	let @"=a:string
	if executable("clip.exe") | call system("clip.exe", a:string) | endif
	if !empty($TMUX) && executable("tmux") | call system("tmux load-buffer -", a:string) | endif
	if !empty($DISPLAY)
		if executable("xclip") | call system("xclip -selection clipboard -in", a:string)
		elseif executable("xsel") | call system("xsel -bi", a:string)
		endif
	endif
	echo "YANK-UP: \"" . strtrans(a:string) . "\""
endfunction

" TODO: check if there is somethinkg like "register pending" mode
" command! YankUp :call YankUp(@")|echo "YankUp: " . strtrans(@")
command! YankUp :call YankUp(@")
nmap YY :YankUp<cr>


" Yank path 
" File path absolute
map YP :call YankUp(expand("%:p"))<cr>
map Ypa :call YankUp(expand("%:p"))<cr>
map Ypp :call YankUp(expand("%:p"))<cr>

" File name
map Ypt :call YankUp(expand("%:t"))<cr>

" File name + line number
map Ypl :call YankUp(expand("%:t") . ":" . line("."))<cr>
map Ypn :call YankUp(expand("%:t") . ":" . line("."))<cr>

" File path absolute + line number
map YpL :call YankUp(expand("%:p") . ":" . line("."))<cr>
map YpN :call YankUp(expand("%:p") . ":" . line("."))<cr>

" File path relative to cwd
map Ypr :call YankUp(expand("%:."))<cr>
map Yp. :call YankUp(expand("%:."))<cr>

" File directory path absolut
map Ypd :call YankUp(expand("%:p:h"))<cr>
map Yph :call YankUp(expand("%:p:h"))<cr>

" File name + current tag
map Ypf :call YankUp(expand("%:t") . ":" . tagbar#currenttag('%s', 'f'))<cr>
" File path absolute + current tag
map YpF :call YankUp(expand("%:p") . ":" . tagbar#currenttag('%s', 'f'))<cr>
" File name + current tag + relative line number
map Yps :call YankUp(expand("%:t") . ":" . tagbar#currenttag('%s:%l', 'f'))<cr>
" File path + current tag + relative line number
map YpS :call YankUp(expand("%:p") . ":" . tagbar#currenttag('%s:%l', 'f'))<cr>

" Add file path to search path
map YpH :execute("set path+=" . expand("%:p:h"))<cr>:set path?<cr>
" Remove file path to search path
map Ypx :execute("set path-=" . expand("%:p:h"))<cr>:set path?<cr>
" }}}
" Special operations {{{
" Setup colorschema {{{
" au BufEnter,BufNew,OptionSet * if &diff | let g:solarized_diffmode="normal" | colorscheme solarized | set diffopt= | else | colorscheme Tomorrow-Night | endif
" TODO:
" -output name of schema
" -make schema persist over session
nmap <F6> :NextColorScheme<CR>
map <leader>n :colorscheme Tomorrow-Night<cr>
try
    colorscheme seoul256 | let g:airline_theme='qwq'
    " colorscheme gruvbox| let g:airline_theme='pencil'
    " colorscheme spring-night | let g:airline_theme='night_owl'
    " colorscheme solarized | let g:airline_theme='solarized_flood'
catch
endtry
hi Folded cterm=NONE
nnoremap zO zczO
nnoremap zm zM
nnoremap zM zm
" TODO: Add "default" foldexprs for
" -ascii trees (uftrace,etc.)
" -dash/line separators
" foldexpr for path-like lists
function! FoldExprAsciiTree(lnum)
    return len(split(getline(a:lnum), "/"))
endfunction
function! FoldExprPath(lnum)
    return len(split(getline(a:lnum), "/"))
endfunction
" foldexpr for single space indention
function! FoldExprSpace(lnum)
    return matchend(getline(a:lnum), "\\S")
endfunction
set foldexpr=FoldExprSpace(v:lnum)
"}}}
" Open log files at the bottom of the file {{{
" TODO: autocmd.txt is not so clear about the the interpretation of slashes in face of multiple comma-separated {pat}s
autocmd vimrc BufReadPost *.log normal G
autocmd vimrc BufReadPost */log/* normal G
autocmd vimrc BufReadPost *.log :set filetype=messages
"}}}
" Restore last position in file upon opening a file {{{
autocmd BufReadPost * call RestorePosition()
function! RestorePosition()
    if !exists("b:_goto_pos") || b:_goto_po
	if line("'\"") > 0
	    if line("'\"") <= line("$")
		execute "norm `\""
	    else
		execute "norm $"
	    endif
	endif
    else
	let b:_goto_pos = 1
    endif
endfunction
"}}}
" Configure help system {{{
runtime! ftplugin/man.vim
nmap K :exe "Man " . expand("<cword>") <CR>
autocmd vimrc FileType man set sidescrolloff=0
autocmd vimrc FileType man wincmd L
let g:ft_man_open_mode = 'vert'
let g:ft_man_folding_enable = 1

autocmd vimrc FileType vim nmap <buffer> K :exe "help " . expand("<cword>")<CR>
autocmd vimrc FileType help nmap <buffer> q <c-w>c
autocmd vimrc FileType help set nonumber
autocmd vimrc FileType help set sidescrolloff=0
autocmd vimrc FileType help wincmd L
" autocmd vimrc FileType help wincmd L | vert resize 80
" }}}
" Setup cursorcolumn {{{
" Add a cursorline(/cursorcolumn) to the active window
" autocmd vimrc BufWinLeave * set nocursorline |
"	    \ highlight CursorLineNr ctermbg=grey

autocmd vimrc BufRead,BufNewFile *.strace set filetype=strace
autocmd vimrc BufWinEnter * set cursorline |
	    \ highlight CursorLineNr ctermfg=white |
	    \ highlight CursorLineNr ctermbg=red |
	    \ highlight CursorLine cterm=underline
set cursorline
set cursorcolumn
" }}}
" Setup listchars {{{
" set listchars=tab:\|\ ,trail:+,extends:>,precedes:<,nbsp:.
" TODO: the following setting gives very slow rendering on macOS
set listchars=tab:â€£\ ,trail:_,extends:â†¦,precedes:â†¤,nbsp:âˆ™
" set listchars=tab:â†’\ ,trail:Â·,eol:Â¬,extends:â€¦,precedes:â€¦
" let &showbreak = 'â†³'
" set list
highlight SpecialKey ctermfg=DarkRed ctermbg=NONE
highlight NonText ctermfg=DarkGreen ctermbg=NONE
" }}}
" Setup spell checking {{{
hi SpellBad ctermbg=none ctermfg=red cterm=undercurl
nmap <leader>zz ]seas
nmap zZ :spellr<cr>
set lazyredraw
au BufRead *.md set filetype=markdown | if expand("%:p") =~ '.*/Notizen/.*' | echo "spell german" | setl spelllang="de_20" | else | echo "NO german" | endif
autocmd vimrc BufReadPost *.mk :set filetype=make
" }}}
" Function: page output of vim commands {{{
command! -nargs=1 -complete=command Redir call <SID>Redir(<f-args>)
function! s:Redir(cmd) abort
    let l:oldz = @z
    redir @z
    silent! exe a:cmd
    redir END
    new
    silent! put z
    let @z = l:oldz
    " Remove blank lines and superfluous greater-than symbol (silently)
    silent! %g/^[\s>]*$/d
    execute "saveas /tmp/redir-vim-" . strftime('%F__%T')
    set wrap
endfunction
command! -nargs=0 Messages call <SID>Redir("messages")
" }}}"
" Function: relax search pattern {{{
" TODO: merge with Andrew Radev
" TODO: relax numbers to \d+
command! -nargs=0 RelaxSearchPattern call <SID>RelaxSearchPattern()
function! s:RelaxSearchPattern() abort
	let @/=substitute(@/, "^\\V", "", "g")
	let @/=substitute(@/, "_", ".*", "g")
	let @/=substitute(@/, " ", ".*", "g")
	let @/ = inputdialog("New search pattern: ", @/)
endfunction
" TODO: Find out why first mapping does not work
" nmap <leader>/ call RelaxSearchPattern()
nmap <leader>/ :RelaxSearchPattern<cr>
" }}}
" Miscellaneous {{{
match ErrorMsg /error/
2match WarningMsg /warning/
" highlight too long lines
" match Error /\%>80c/
function! s:create_toggle_map(letter, test, off, on)
	execute 'nnoremap [o' . a:letter . ' :' . a:on . '<CR>'
	execute 'nnoremap ]o' . a:letter . ' :' . a:off . '<CR>'
	execute 'nnoremap co' . a:letter . ' :' . '<C-r>=' . a:test . '?"' . a:off . '":"' . a:on . '"<CR><CR>'
endfunction
call s:create_toggle_map('t', 'match(&colorcolumn, "+1")>=0', 'set colorcolumn-=+1', 'set colorcolumn+=+1')

autocmd vimrc BufRead *.jar,*.apk,*.war,*.ear,*.sar,*.rar set filetype=zip
autocmd vimrc BufRead,BufNewFile *.ipy set filetype=python

" Netrw
autocmd vimrc FileType netrw nmap <buffer> q <c-w>c
let g:netrw_liststyle         = 3
let g:netrw_banner            = 0
" let g:Netrw_UserMaps= [
"     \    ["l","execute('wincmd l')"]
"     \    ["<c-l>","execute('wincmd l')"]
"     \]

function! EnableAutoWrite()
    exe ":au FocusLost" expand("%") ":update"
endfunction
command! DiffOrig vert new | set bt=nofile | r # | 0d_ | diffthis | wincmd p | diffthis

autocmd vimrc SwapExists * let v:swapchoice = "o"

" Prevent delay after quitting input mode
" TODO: This seems to be unreliable
" set noesckeys
" vim-pstree {{{
" TODO:
" -Make tree generation recurring in the background with a regular interval
" -Add maps
" --to switch from user-generated pstrees and regular generated pstrees
" --Dispatch strace, gdb, r2, etc.
" --To reload procps-files by 'r'
" -Mark timestamps which coincide with user generated updates
" -Diff pstrees
" -Highlight groups for
"  --Unusual flags
"  --Interactive programms without tty
"  --load/mem-pressure
"  --uncommon pending syscalls
"  --own tty
"  --other users than self/system-accounts/root
" Map for terminal info/search
" R: reload with search on PID
function! ProcessTreePid()
    return substitute(getline('.'), '^\s*\(\d*\)\s.*$','\1','g')
endfunction
let g:pst_fold_columns = 12 " TODO: set this dynamically for current process tree?

let g:pst_fields = [
	\ { 'name': 'pid',       'width':  6, },
	\ { 'name': 'ppid',      'width':  6, },
	\ { 'name': 'stat',      'width':  6, },
	\ { 'name': 'flag',      'width':  2, },
	\ { 'name': 'user',      'width':  8, },
	\ { 'name': 'tty',       'width':  8, 'title': 'TTY' },
	\ { 'name': 'lstart',    'width': 40, },
	\ { 'name': 'wchan',     'width': 15, 'title': 'SYSCALL' },
	\ { 'name': '\%cpu',     'width':  8, },
	\ { 'name': '\%mem',     'width':  8, },
	\ { 'name': 'args', },
    \]
" \ { 'name': 'cgname',      'width':  165, 'detail': 3 },
" \ { 'name': 'sz',   'width': 12, 'title': "" },
" \ { 'name': 'drs',   'width': 12, 'title': "" },
" \ { 'name': 'luid',   'width': 12, 'title': "" },
" \ { 'name': 'lwp',   'width': 12, 'title': "" },
" \ { 'name': 'lxc',   'width': 12, 'title': "" },
" \ { 'name': 'nice',   'width': 12, 'title': "" },
" \ { 'name': 'sess',   'width': 12, 'title': "" },
" \ { 'name': 'seat',   'width': 12, 'title': "" },
" \ { 'name': 'maj_flt',   'width': 12, 'title': "" },
" \ { 'name': 'maj_flt',   'width': 12, 'title': "" },
" \ { 'name': 'min_flt',   'width': 12, 'title': "" },
" \ { 'name': 'cputime',   'width': 12, 'title': "" },
" \ { 'name': 'cputime',   'width': 12, 'title': "CPU-TIME" },
" \ { 'name': 'bsdtime',   'width': 12, 'title': "ACC-TIME" },
" \ { 'name': 'class',   'width': 12, 'title': "CLASS" },

function! Fields_to_psparm()
    let ret = ""
    for field in g:pst_fields
	let ret .= " -o " . field.name
	if has_key(field, "width") && field.width > 0 | let ret .= ":". field.width | endif
	if has_key(field, "title") && len(field.title) > 0 | let ret .= "=". field.title | endif
    endfor
    return ret
endfunction

function! Field_to_colnum(field_name)
    let col=1
    for field in g:pst_fields
	if has_key(field, "width") && field.width > 0 | let col += 1 + field.width | endif
	if field.name == a:field_name
	    break
	endif
    endfor
    return col
endfunction

function! Field_to_colregex(field_name, regex)
    let col=1
    for field in g:pst_fields
	if field.name == a:field_name
	    return "\\%>" . col . "c" . a:regex . "\\%<" . (1 + col + field.width) . "c"
	endif
	let col += field.width
    endfor
endfunction

function! PsEnableCsvVim()
    let col=1
    let fixed_width_string = "1"
    for field in g:pst_fields
	if has_key(field, "width") | let col += 1 + field.width | endif
	let fixed_width_string .= "," . col
    endfor
    set filetype=csv
    let b:csv_fixed_width = fixed_width_string
    CSVInit
endfunction

function! PsSendSignal(pid, signal)
    let line_num = line(".")
    silent! execute "!kill -" . a:signal . " " . a:pid
    echomsg "Sent " . a:signal . " to " . a:pid . "."
    ProcessTree()
    execute "norm " . line_num . "G"
endfunction

function! PsFoldExpression(lnum)
    let arg_index = Field_to_colnum("arg")
    if arg_index <= 0 | return 1 | endif
    let match_index = match(getline(a:lnum), '\%>' . arg_index . 'c[|_\ ]*\zs\f*')
    if match_index <= arg_index | return 1 | endif
    return 1 + (match_index - arg_index) / 3
endfunction

function! PsProcessDetails(pid)
    let proc_path="/proc/" . a:pid
    execute("tabnew " . proc_path . "/stack | se ft=sh")
    execute("split " . proc_path . "/maps | se ft=sh")
    execute("split " . proc_path . "/status | se ft=sh")
    " execute("NERDTree " . proc_path . "/task/ | norm ul?fdl")
    execute("NERDTree " . proc_path . "/task/ | norm ul")
    " execute("NERDTree " . proc_path . "/fd/ | norm ul")
    execute("TabooRename " . a:pid)
endfunction

function! ProcessTree(...)
    " if a:0 == 1 | let pid=a:1 | else | let pid=ProcessTreePid() | endif
    let l:current_line_num = line(".")
    let l:current_fold_level = &foldlevel
    " let @/ = Field_to_colregex("pid", "\\<".pid."\\>")
    " Create new buffer for current pstree
    execute("e ps-" . strftime('%F_%T'))
    execute("TabooRename " . strftime('%F_%T'))
    " Add buffer-local mappings
    nnoremap <buffer> ( :call PsSendSignal(ProcessTreePid(), "KILL")<cr>
    " nnoremap <buffer> D :execute("!tmux splitw gdb -q -p ") . ProcessTreePid()<cr>i
    nnoremap <buffer> D :execute("silent! !tmux splitw gdb -q -p ") . ProcessTreePid()<cr>
    nnoremap <buffer> <leader>D :execute("tabnew term://gdb -q -p ") . ProcessTreePid()<cr>i
    nnoremap <buffer> i :call PsProcessDetails(ProcessTreePid())<cr>
    nnoremap <buffer> K :call PsSendSignal(ProcessTreePid(), "TERM")<cr>
    nnoremap <buffer> C :call PsSendSignal(ProcessTreePid(), "CONT")<cr>
    nnoremap <buffer> r :call ProcessTree()<cr>
    nnoremap <buffer> S :call PsSendSignal(ProcessTreePid(), "STOP")<cr>
    " nnoremap <buffer> t :execute("Dispatch! sudo strace -p ") . ProcessTreePid()
    nnoremap <buffer> t :execute("bot split term://strace -p ") . ProcessTreePid()<cr>
    nnoremap <buffer> yp :call YankUp(ProcessTreePid())<cr>
    " Fill buffer with ps output
    execute "silent read !ps -e --forest " . Fields_to_psparm()

    set buftype=nofile filetype=sh cursorline nonumber norelativenumber nowrap
    silent! ALEDisable
    " Cut header from ps output
    silent! norm ggdd0"ad$ddn
    " Delete old header - if any
    wincmd k
    if bufname("") == "HEADER" | bdelete! | endif
    " Move header into separate window
    1new HEADER | set nobuflisted noswapfile | wincmd k | norm "aP0
    set buftype=nofile nonumber norelativenumber nowrap
    let &foldcolumn=g:pst_fold_columns
    wincmd j
    execute "norm " . l:current_line_num . "G"
    set nowrap
    let &foldcolumn=g:pst_fold_columns
    set foldexpr=PsFoldExpression(v:lnum)
    set foldmethod=expr
    let &foldlevel=l:current_fold_level
    " set foldenable
    " norm zv
    " call PsEnableCsvVim()
endfunction
command! -nargs=* ProcessTree call ProcessTree(<f-args>)

let s:StatusbarHidden = 0
function! StatusbarToggle()
	if s:StatusbarHidden  == 0
		let s:StatusbarHidden = 1
		set noshowmode
		set noruler
		set laststatus=0
		set noshowcmd
	else
		let s:StatusbarHidden = 0
		set showmode
		set ruler
		set laststatus=2
		set showcmd
	endif
endfunction
command! -nargs=0 StatusbarToggle call StatusbarToggle()
function! KeepView(cmd)
	let w = winsaveview()
	exec a:cmd
	call winrestview(w)
endfunction
cabbr BB <buffer>
map <leader>00 :call KeepView('silent! %s/\%x0/\r/')<cr>
map <leader>0m :call KeepView('silent! %s/\%xd//')<cr>
map <leader>0s :call KeepView('silent! %s/\s\+\(\S\)/\r\1/')<cr> " TODO: understand why \zs does NOT work
" TODO: Try to find a way to restrict a mapping on a selection if there is a selection and operate on the entire buffer if there is no selection
map <leader>0, :call KeepView("silent! '<,'>s/,/\r/")<cr>
" map <leader><space><cr> :call KeepView("silent! '<,'>s/\s\+/\r/")<cr>
" map <leader><space><cr> :s/\s\+/\r/<cr>
map <leader><leader><cr> :s/\s\+/\r/<cr>
map <leader><leader>,<cr> :s/,\+/\r/<cr>
map <leader>0; :call KeepView("silent! '<,'>s:\\s*;\\s*:\r")<cr>

map <c-w>k :close<cr>
map <c-w><c-k> :close<cr>

" let cmd_prefix='ssh quec sudo qmicli -d /dev/cdc-wdm0'
" let cmd_prefix='sudo qmicli -d /dev/cdc-wdm0'
let cmd_prefix='sudo mbimcli -d /dev/cdc-wdm0'
" let cmd_prefix='qmicli -d /dev/cdc-wdm0'
" let cmd_prefix='sudo mbimcli -d /dev/cdc-wdm0'
" map M :let s=substitute(expand('<cWORD>'), ",$", "", "")<cr>:echo s<cr>:let cmd="!tmux send -t 2 \"echo " . shellescape(cmd_prefix . " " . s) . "\" Enter"<cr>:echo cmd<cr>:execute(cmd)<cr>
map M :let s=substitute(expand('<cWORD>'), ",$", "", "")<cr>
	    \ :let @0=system(cmd_prefix . " " . s . " --device=/dev/cdc-wdm0")<cr>
	    \ "0p<}
" }}}
" Prevent vim from moving cursor after leaving insert mode
" TODO: try to understand why vim does this
" au InsertLeave * call cursor([getpos('.')[1], getpos('.')[2]+1])
" }}}
" }}}
" Miscellaneous {{{
autocmd vimrc BufReadPost *-strace*,strace\.* setfiletype strace

function! ALEInformation()
    " TODO: Make this work
    Redir("call ale#debugging#Info()")
    set filetype=sh
    set wrap
endfunction
command! -nargs=0 ALEInformation call ALEInformation()

nmap <leader><c-h> :colder<cr>
nmap <leader><c-l> :cnewer<cr>
command! -bang -nargs=? QFixToggle call QFixToggle(<bang>0)
function! QFixToggle(forced)
  if exists("g:qfix_win") && a:forced == 0
    cclose
    unlet g:qfix_win
  else
    copen 10
    let g:qfix_win = bufnr("$")
  endif
endfunction
nmap <leader>q :QFixToggle<cr>

autocmd! FileType fzf
autocmd  FileType fzf set laststatus=0 noshowmode noruler nonumber norelativenumber cmdheight=1
	    \| autocmd BufLeave <buffer> set laststatus=2 showmode ruler

au FileType qf call TweakQf(3, 16)
function! TweakQf(minheight, maxheight)
	nmap <buffer> J /error:<cr>
	nmap <buffer> K ?error:<cr>
	nmap <buffer> ; <cr><c-w><c-w>
	nmap <buffer> p <cr><c-w><c-w>
	nmap <buffer> s <cr><c-w>s<c-^><c-w><c-w><c-w><c-w>
	" exe max([min([line("$"), a:maxheight]), a:minheight]) . "wincmd _"
	set nowrap
endfunction

map <leader>_ :s/\s\+/\r/<cr>
map <leader>_ :s/\s\+/\r/<cr>
vmap <leader>_ :'<,'>s/\s\+/\r/<cr>
map <leader><leader><cr> :s/\s\+/\r/<cr>
vmap <leader><leader><cr> :'<'>s/\s\+/\r/<cr>
cmap <m-v> <c-r>"

map <c-w><c-l> <c-w>v<c-w>l
map <c-w><c-j> <c-w>s<c-w>j

function! ToggleOption(name)
	silent execute "set " . a:name . "!"
	execute "set " . a:name . "?"
endfunction

nmap <silent> com :call ToggleOption("modifiable")<cr>
nmap <silent> coR :call ToggleOption("readonly")<cr>
nmap <silent> coe :call ToggleOption("eol")<cr>

function! StripHtml()
	if executable("w3m")
		execute "%!w3m -s -dump -T text/html"
	else
		echoerr "TODO: Add some regex helper"
	endif
endfunction
command! StripHtml call StripHtml()

function! ToggleTabsize()
	if &ts == 8
		let &ts = 4
		let &sw = 4
	else
		let &ts = 8
		let &sw = 8
	endif
endfunction
nmap co8 :call ToggleTabsize()<cr>

function! TrimWhitespace()
	let l:save = winsaveview()
	keeppatterns %s/\s\+$//e
	call winrestview(l:save)
endfunction
command! TrimWhitespace call TrimWhitespace()
map <leader><S-S>e :%s:\(\<1\d\{9\}\>\):\=strftime("\"%F %T\"",submatch(0)):c<cr>
" nmap <leader>e yq:new\<CR>P:%s:\\n::\<CR>:se ft=javascript\<CR>"
" Edit string inline replacing \n
" autocmd vimrc FileType dosini,json  nmap <buffer> <leader>e yq:new<CR>P:%s:\\n:\r:<cr>gg:se ft=javascript<cr>
autocmd vimrc FileType json  nmap <buffer> <leader>e yq:new<CR>P:%s:\\n:\r:<cr>gg:se ft=sql<cr>
" Re-paste string joined with \n
" autocmd vimrc FileType javascript   nmap <buffer> <leader>e ggGk$A\\n\<Esc>0vaeJ0yy:bdel!<cr>viq
autocmd vimrc FileType sql   nmap <buffer> <leader>e ggGk$A\\n\<Esc>0vaeJ0yy:bdel!<cr>viq
vmap / /\%V
nmap v/ /\V
"}}}

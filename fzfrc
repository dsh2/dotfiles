# vim:ft=zsh
# TODO
# -Add binding to pin current item to then relax the filter in order to
#  explore the environment
# -Add some means to add an ordering to the selection of --multi
# -Add some means to match content in a particular column


fzf_binds=()
fzf_binds+=(
	alt-a:select-all
	alt-A:deselect-all
	alt-D:first
	alt-d:page-down
	alt-U:last
	alt-u:page-up
)

fzf_binds+=(
	alt-t:toggle-track
)

fzf_binds+=(
	ctrl-r:toggle-sort
	ctrl-q:toggle-preview
	ctrl-alt-j:preview-page-down
	ctrl-alt-k:preview-page-up
	ctrl-alt-l:toggle-preview-wrap
	ctrl-l:cancel
	ctrl-o:toggle-all
	ctrl-n:next-history
	ctrl-p:previous-history
	tab:toggle-up
	shift-tab:toggle-down
)

fzf_binds+=( "'ctrl-x:execute(echo -n {+} | zsh -ic clip)'")

fzf_binds+=( "'ctrl-t:execute(echo -n {+} | tmux load-buffer -)'")

fzf_options=(
	ansi
	exact
	multi
	inline-info
	history=${HOME}/.fzf_history
)

export FZF_DEFAULT_OPTS="${(@)fzf_binds/#/--bind } ${(@)fzf_options/#/--}"
unset fzf_binds fzf_options

FZF_TMUX=1
FZF_TMUX_HEIGHT=90%

# TODO: add binding for vared
ee() {
    typeset | fzf --multi | cut -d= -f1
}

fbr() {
    local refs_filter=${*}
    local object
    object=$(git -c color.ui=always for-each-ref \
		${refs_filter} \
		  --format="%(HEAD)%(color:red)%(objectname:short)%(color:reset) %09 (%(color:green)%(committerdate:local) - %(committerdate:relative)%(color:reset)) %09 %(color:yellow)%(refname:short)%(color:reset) %(contents:subject) (%(color:green)%(authorname)%(color:reset))" \
		  --sort=-committerdate |
      fzf-tmux --tabstop=14 --ansi --no-sort | cut -f 1 | tr -d \*)
    echo sha1 = $object
    git checkout $=object
}

fbT() { fbr "refs/tags" }
fbS() { fbr "refs/stash" }
fbR() { fbr "refs/heads" }

# fshow - git commit browser
fshow() {
  git log --all --graph --color=always \
      --format="%C(auto)%h%d %s %C(black)%C(bold)%cr" "$@" |
  fzf --ansi --no-sort --reverse --tiebreak=index --bind=ctrl-s:toggle-sort \
      --bind "ctrl-m:execute:
                (grep -o '[a-f0-9]\{7\}' | head -1 |
                xargs -I % sh -c 'git show --color=always % | less -R') << 'FZF-EOF'
                {}
FZF-EOF"
}

# fs - tmux session management
fs() {
  local session
  session=$(tmux list-sessions -F "#{session_name}" | \
    fzf --query="$1" --select-1 --exit-0) &&
  tmux switch-client -t "$session"
}

ftpane() {
  # TODO:
  # -check if already running
  # -focus self
  # -what about colors
  panes=$( \
    tmux list-panes -aF '#{window_activity_flag} #{window_bell_flag} #{window_silence_flag} #{window_stack_index} #{wrap_flag} #{window_flags}\t#{t:window_activity}\t[#{session_name}]\t#{window_index}|#{=13:window_name}\t#{s,/dev/,,:pane_tty}\t#{pane_id}\t#{pane_pid}\t#{pane_index}|#{=13:pane_current_command}\t#{pane_current_path}:#{pane_title}' |
	sort -k 7dr |
    grep -v $$ # TODO: add \t-regex
    )
  target=$(echo "$panes" | fzf +m --header=A\ B\ S\ I\ W\ F\ $'\t'\[ACTIVITY\]$'\t\t'\[SESSION\]$'\t'\ \|WINDOW$'\t'TTY$'\t'P_ID$'\t'P_PID$'\t'\ \|PANE$'\t'CWD:TITLE --tabstop=14 --layout=reverse ) || return
  tmux switch-client -t $(echo $target | cut -f 6)
}

# gch - browse chrome history
gch() {
	local title_width sep tmp_file
	title_width=$(( COLUMNS / 2 ))
	sep='{{::}}'
	tmp_file=$(mktemp)
	cp -f "$HOME/.config/google-chrome/Default/History" $tmp_file &&
		sqlite3 -separator $sep $tmp_file  \
			"select datetime((last_visit_time/1000000)-11644473600, 'unixepoch', 'localtime'), visit_count, substr(title, 1, $title_width), url from urls order by last_visit_time desc" |
		awk -F $sep '{printf "%s #%s %-'$title_width's  \x1b[36m%s\n", $1, $2, $3, $4}' |
		fzf --ansi --multi \
			--prompt "chrome history ($(jq -c '.["account_info"] | .[0] | .email' "$(dirname "$(readlink  ~/.config/google-chrome-history)")"/Preferences)): " |
		sed 's#.*\(https*://\)#\1#' | xargs xdg-open > /dev/null 2>&1
	zle && zle redisplay
}
zle -N gch; bindkey '\eU' gch

# gcb - browse chrome bookmarks
gcb() {
	setopt pipefail
	local urls
	urls=$(chrome-bookmarks.rb |
	    sort -r |
	    fzf \
		--ansi \
		--bind 'ctrl-x:execute(cut -f 3 <<< {} | xclip -selection clipboard -in)' \
		--prompt "chrome bookmarks ($(jq -c '.["account_info"] | .[0] | .email' ~/.config/google-chrome/Default/Preferences)): " \
		--multi |
	    cut -f 3) &&
	    xdg-open $=urls
}
zle -N gcb;
bindkey '\eB' gcb
bindkey '\eI' gcb

# twf - browse twitter favorites
twf() {
	setopt pipefail
	local tweed_ids
	# sed -n '/^[[:digit:]]\{15,\}/{x;p;d};H;x;s/\r\n/ /g;x'
	tweed_ids=$(t favorites --long --number 1000 |
	    fzf \
		--ansi \
		--prompt "twitter favs: " \
		--multi |
	    sed -nE 's,([0-9]* ).*,https://twitter.com/statuses/\1,p' ) &&
	    exo-open $=tweed_ids
}
zle -N twf; bindkey '\eT' twf


__fzfz() {
    unset REPORTTIME
    eval "z -l|cut -f 2" | fzf --prompt='z (dirs): ' --tac --tiebreak=index -m --preview="ls --color=always -al {} " |
	while read item; do
	    printf '%q ' "$item"
	done
	echo
    }

fzfz_file_widget() {
  LBUFFER="${LBUFFER}$(__fzfz)"
  zle redisplay
}

zle     -N   fzfz_file_widget
bindkey '^G' fzfz_file_widget

fzf_locate_widget() {
    BUFFER="$LBUFFER$(
	command locate \* |
	    fzf --multi --prompt='locate: ' --preview="file {}" |
	    while read file; do
		qfile="${(q)file} "
		CURSOR+=$#qfile # FIXME: cursor does not advance
		echo -n $qfile
	    done
    )$RBUFFER"
    zle redisplay
}
zle -N fzf_locate_widget; bindkey '^x^l' fzf_locate_widget

zsh_history() {
	local col
	local -a cols=()
	local -a where=()
	local distinct=""
	while [[ $# -gt 0 ]]; do
		col=$1; shift
		[[ $col == -d ]] && {
			# If last arg is -d make command_oneline distinct (below)
			[[ $# -gt 0 ]] || { distinct="group by command "; break; }
			shift
			cols+="distinct $1"
			continue
		}
		[[ $# -gt 0 ]] || {
			cols+=$col
			break
		}
		opp=${1[2,-1]}
		case ${1[1]} in
			# Exact comparison
			(=) shift; where+=($col=$( quote_strings $opp)) ;;
			# Prefix match
			(\*) shift; where+=($col like '${opp}%') ;;
			# No operator
			(*) cols+=$col ;;
		esac
	done
	local -r zs3cols="${(j:, :)cols}${${cols}:+,}"
	local zs3where=""; (( $#where > 0 )) && zs3where="where ${(j: and :)where}"
	zs3r ".mod tabs" ".nullvalue â›”" "select log_dir, $zs3cols trim(command, char(0x0a,0x0d,0x20)) from history $distinct $zs3where order by log_dir desc"
}

# Generate and output a list of zsh activities documented in $__zsh_history_base_dir. List may contain multiple
# columns generated off of the files to be found in the runtime directories within $__zsh_history_base_dir.
zsh_history_fs() {
	[[ -v zsh_debug ]] && set -x
	# set -x
	mkdir -p $__zsh_history_base_dir $__zsh_history_cache_dir
	fields=($@)
	fields+=("command_oneline")
	local -ir cols=${#${fields/[#=*]*/}}
	# Create a separate cache for all fields (and its filters/operators)
	local cache_file=$__zsh_history_cache_dir/${(j:-:q)fields:gs./._.}
	# Sponge seems sometimes a little buggy leaving target file empty
	local cache_file_tmp=$cache_file-tmp
	local changed_after=""
	local -i cache_mtime=0
	if [[ -r $cache_file ]]; then
		cache_mtime=$(stat +mtime $cache_file)
		changed_after="--changed-after=@$cache_mtime"
	else
		# In case fd finds a lot of dirs but all dirs fail their field comparisons, touch cache file
		# so fd won't find these dirs again in later invocations of zsh_history.
		touch $cache_file
	fi
	# --max-results 10 \
	(
		fd \
			$changed_after \
			--type directory . $__zsh_history_base_dir |
		while read -r dir; do
			[[ -s $dir/command_oneline ]] || continue
			local -a out=($dir)
			set $fields
			while [[ $# -gt 0 ]]; do
				field=$1; shift
				local value=""
				# [[ -r $dir/$field ]] && value="${(q)$(<$dir/$field)}"
				value=$(<$dir/$field) 2>/dev/null
				# XXX: Skip whole line as soon as one field value is missing?
				[ -z $value ] && continue
				if [[ $# -gt 0 ]]; then
					opp=${1[2,-1]}
					case ${1[1]} in
						# Exact comparison
						(=) shift; [[ $value != $opp ]] && continue 2 ; continue ;;
						# Prefix match
						(\*) shift; [[ $value =~ ^${~opp} ]] && continue 2 ; continue ;;
						# No operator, i.e. next field's name; fall-through and output current field's value
						(*) ;;
					esac
				fi
				out+=( $value )
			done
			# Do not interpret (-R) escape seqeunces in values
			for o in $out; do print -nR $o ; print -n $'\t'; done
			print
	done |
		# Only show unique commands
		sort -t$'\t' -uk$(( 1 + cols )) |
			sort --reverse
		cat $cache_file
	) | tee $cache_file_tmp

	(( $( file_size_bytes $cache_file_tmp ) > $( file_size_bytes $cache_file ) )) &&
		mv $cache_file_tmp $cache_file
	set +x
}

file_size_bytes() { stat +size $1 }

# CTRL-R - Paste the selected command from history into the command line
# TODO: allow --multi and add binding to vimdiff the outputs

declare __zsh_history_cache_dir=~/.cache/zsh_history/
declare -i __zsh_history_mode_max=6
declare -a __zsh_history_fields_extra=()

optional_quote() { [[ $1 == *[[:space:]]* ]] && print -r -- \'$1\' || print -r -- $1 }
quote_strings() { [[ $1 == *[[:alpha:]]* ]] && print -r -- \'$1\' || print -r -- $1 }

fzf-history-widget() {
	setopt localoptions noglobsubst noposixbuiltins
	declare -i __zsh_history_mode_index=1
	local -a fzf_options=()
	# fzf_options+=( info=inline )
	fzf_options+=( info=inline-right:\* )
	# fzf_options+=( tmux=bottom,70% )
	# fzf_options+=( tmux=100% )
	# fzf_options+=( tmux=center )
	# fzf_options+=( border-label=bold )
	# fzf_options+=( style=full )
	# fzf_options+=( border=double )
	fzf_options+=( multi )
	fzf_options+=( no-sort )
	# fzf_options+=( track )

	local -a fields_common_start=( "date_start" )
	# Start fzf query with what is on the command line already
	local query="${LBUFFER//$/\\$}"
	# TODO: rename local to path-local
	# TODO: add local mode in the sense of zsh terminology
	# TODO: add path-local-recursive
	local -r accept_key=ctrl-m
	local -r mode_switch_key=ctrl-space
	local -r mode_switch_back_key=alt-backspace
	local -r reload_key=alt-r
	local -r diff_key=ctrl-alt-d
	local -r cols_key=alt-C
	local -r remove_key=alt-X
	local -r nuke_key=ctrl-alt-n
	local -r unique_key=ctrl-alt-u
	local -ra all_expect_keys=(
		$accept_key
		$mode_switch_key
		$mode_switch_back_key
		$reload_key
		$diff_key
		$remove_key
		$nuke_key
		$unique_key
	)
	apply_mode
	while :; do
		local -a fields=( $fields_common_start $__zsh_history_fields_extra )
		local -a fzf_result=("${(f)$(
			(
			# TODO: Add support for nested abortion
				# [[ -n $ZLE_LINE_ABORTED ]] &&
					# echo -e $aborted_id\\t$(date +$time_format)\ $ZLE_LINE_ABORTED ;
				zsh_history "$fields[@]"
			) |
				# --header=${(j:	:)fields} \
				# --header-lines=2 \
			fzf \
				${(@)fzf_options/#/--} \
				--expect=${(j:,:)all_expect_keys} \
				--accept-nth=1 \
				--with-nth=2.. \
				--print-query \
				--tiebreak=chunk,begin,index \
				--preview-window up:45% \
				--preview "preview.sh {1} {q}" \
				--bind "ctrl-/:change-preview-window(70%,right|hidden|)" \
				--bind "ctrl-v:execute(tmux split -v $EDITOR {1}/)" \
				--bind "zero:hide-preview" \
				--bind "change:show-preview" \
				--bind "resize:refresh-preview" \
				--query=$query \
				--prompt="($__zsh_history_mode_index) [$__zsh_history_fzf_prompt]: "
		)}")
		# --prompt="[$__zsh_history_fzf_prompt ($__zsh_history_mode_index)]: "
		#
		# Save current fzf query for further invocations of fzf
		query=$fzf_result[1]
		local key=$fzf_result[2]
		local -i cnt=$(( $#fzf_result - 2 ))
		case "$key" in
			($accept_key)
				(( cnt == 0 )) && {
					BUFFER=$query
					zle redisplay
					zle -M "fzf returned empty selection. Retaining fzf query in BUFFER, i.e. \"$query\"."
					return
				}
				set ${fzf_result:2}
				BUFFER=""
				while [[ $# -gt 0 ]]; do
					BUFFER+=$( < $1/command_oneline )
					shift
					[[ $# -gt 0 ]] && BUFFER+='; '
				done
				# zle -M "New buffer (cnt=$cnt): \"$BUFFER\""
				return 0
				;;
			($diff_key)
				(( cnt < 2 )) && {
					zle redisplay
					zle -M "Select at least 2 entries (cnt=$cnt)."
					sleep 2
					continue
				}
				set ${fzf_result:2}
				$EDITOR -d ${*/%/\/output.gz}
				;;
			($mode_switch_key)
				__zsh_history_mode_index=$(( (__zsh_history_mode_index + 1) % __zsh_history_mode_max ))
				apply_mode
				;;
			($mode_switch_back_key)
				__zsh_history_mode_index=$(( (__zsh_history_mode_index - 1 + __zsh_history_mode_max) % __zsh_history_mode_max ))
				apply_mode
				;;
			($unique_key)
				# TODO: Toggle -d as last extra field
				;;
			($nuke_key)
				set ${fzf_result:2}
				zle redisplay
				zle -M "Nuking $*"
				command rm -rfI $*
				sleep 3s
				;;
			($reload_key)
				# command rm -rf $__zsh_history_cache_dir/*
				zle -M "Reloading current history"
				;;
			(*)
				zle redisplay
				zle -M "fzf returned empty key. Not modifying BUFFER."
				return
		esac
	done
}

abbrev_path() {
	local path=$1
	local -a parts abbrev
	local IFS='/'

	# Split into path components
	parts=(${(s:/:)path})

	# Rebuild with abbreviation
	for ((i = 1; i < ${#parts}; i++)); do
		abbrev+=(${parts[i]:0:1})
	done

	# Append last component in full (if any)
	(( ${#parts} )) && abbrev+=(${parts[-1]})

	# Join with slashes
	print -r -- "/${(j:/:)abbrev}"
}

apply_mode() {
	case $__zsh_history_mode_index in
		(0)
			__zsh_history_fzf_prompt="Global (all)"
			__zsh_history_fields_extra=( "tty" "zsh_pid" "tmux_session_name" "tmux_window_name" "todo" "pwd" )
			;;
		(1)
			__zsh_history_fzf_prompt="Global"
			# __zsh_history_fields_extra=( "-d" )
			__zsh_history_fields_extra=( )
			;;
		(2)
			__zsh_history_fzf_prompt="pwd=$( optional_quote $PWD )"
			__zsh_history_fields_extra=( "pwd" "=$PWD" )
			;;
		(3)
			__zsh_history_fzf_prompt="zsh_pid=$$"
			__zsh_history_fields_extra=( "zsh_pid" "=$$" )
			;;
		(4)
			local tmux_session_name=$( tmux display-message -p '#{session_name}' )
			__zsh_history_fzf_prompt="tmux_session=$( optional_quote $tmux_session_name )"
			__zsh_history_fields_extra=( "tmux_session_name" "=$tmux_session_name" )
			;;
		(5)
			local tmux_window_name=$( tmux display-message -p '#{window_name}' )
			__zsh_history_fzf_prompt="tmux_window=$( optional_quote $tmux_window_name )"
			__zsh_history_fields_extra=( "tmux_window_name" "=$tmux_window_name" )
			;;
		(*)
			zle -M "Illegal mode $__zsh_history_mode_index encountered"
	esac
}

zle     -N   fzf-history-widget
bindkey '^R' fzf-history-widget

# CTRL-R - Paste the selected command from history into the command line
# TODO: allow --multi and add binding to vimdiff the outputs
fzf-history-widget_old() {
	setopt localoptions noglobsubst noposixbuiltins
	local query="${LBUFFER//$/\\$}"
	local -r time_format='%a %F %T'
	local -r aborted_id="ABRT"
	local -r mode_switch_key=ctrl-space
	# TODO: rename local to path-local
	# TODO: add local mode in the sense of zsh terminology
	# TODO: add path-local-recursive
	local -a modes
	modes=("global" "local" "local-recursive" "internal")
	# TODO: make mode persistent across invocation of widget
	# : ${mode_index:=1}
	local -i mode_index=1
	local fzf_prompt="zsh history"
	local mode_fd_param=""
	local -a fzf_result
	while :; do
		fzf_result=("${(f)$(
			(
			# TODO: Add support for nested abortion
				[[ -n $ZLE_LINE_ABORTED ]] &&
					echo -e $aborted_id\\t$(date +$time_format)\ $ZLE_LINE_ABORTED ;
				fc $=mode_fd_param -rlEDt '%a %F  %T' 1 2> /dev/null | sed 's:[[:space:]]$::' | uniq -f 6
			) |
			# TODO: re-enable tmux support
			# $(__fzfcmd) \
			fzf \
			--multi \
			--preview "
				echo COMMAND: {7..} | pygmentize -l zsh;
				# echo EVENT ID: {3..4};
				tmux-log.sh {1}" \
			--preview-window up:45%:wrap \
			--bind "ctrl-v:execute(tmux split -v vim ~/.tmux-log/{1})" \
			--tiebreak=begin,index  \
			--print-query \
			--expect=ctrl-m,$mode_switch_key \
			--query=$query \
			--prompt="$modes[$mode_index] $fzf_prompt: "
		)}")

		query=$fzf_result[1]
		local key=$fzf_result[2]
		case "$key" in
			"ctrl-m")
				local new_cmd_line
				local separator
				local events=(${fzf_result:2})
				for event in $events; do
					local event_id=$event[(w)1]
					[ ${event_id: -1} = "*" ] && { event_id=${event_id: : -1} }
					if [[ $event_id == $aborted_id ]]; then
						new_cmd_line+=$ZLE_LINE_ABORTED
					elif (( event_id )) then
						new_cmd_line+="$separator$history[$event_id]"
					else
						zle -M "fc returned illegal event id (event_id = \"$event_id\")."
					fi
					separator='; '
					# separator=$'\n'
				done
				BUFFER=$new_cmd_line
				CURSOR=$#new_cmd_line
				return
				;;
			"$mode_switch_key")
				mode_index=$((mode_index % $#modes + 1))
				case "$modes[$mode_index]" in
					"global")
						mode_fd_param=""
						fc -P
						;;
					"local")
						mode_fd_param=""
						fc -ap $(zloc_file)
						;;
					"internal")
						mode_fd_param="-I"
						fc -P
						;;
					*)
						print "Illegal mode encountered"; sleep 5
				esac
				;;
			*)
				# zle redisplay
				# zle -M "fzf returned empty key."
				return
		esac
	done
}
zle     -N   fzf-history-widget_old
bindkey "^[r" fzf-history-widget_old

UNAME=$(uname)

LS_COMMAND=ls
if [ "$UNAME" = "Darwin" ]; then
	# TODO: check if gnu core utils is installed
	alias find=gfind
	alias locate=glocate
	LS_COMMAND=gls
	alias sed=gsed
	alias tac=gtac
	# Switch profile of running iTerm2 window
	it2prof() { printf '\033]50;SetProfile=$@\a'; }
fi

if [ "$OSTYPE" = "cygwin" ]; then
	alias sudo="cygstart --action=runas"
fi

# Change directory
alias ....='cd ../../..'
alias ...='cd ../..'
alias ..='cd ..'
alias cdd=popd
source ~/.dotfiles/z/z.sh

# AOSP
alias aosp='cd "$AOSP_HOME" && source build/envsetup.sh && export OUT_DIR_COMMON_BASE="$AOSP_HOME/out.$MYHOSTNAME"'
alias adbk='adb shell input keyboard text'
alias adl='adb logcat -v threadtime ThermalEngine:S DownloadManagerWrapper:S WifiConfigStore:S wpa_supplicant:S NewsWeather:S WifiStateMachine:S WifiService:S |& lnav -w ~/.logs/adb-logcat/$(date "+%F-%T").log'
alias adll='adb logcat -v threadtime |& lnav -w ~/.logs/adb-logcat/$(date "+%F-%T").log'
alias add='adb devices -l'
alias ads='adb shell '
alias aps='adb shell ps '
ash() {
	[ -z "$ANDROID_SERIAL" ] && ANDROID_SERIAL=$(adb get-serialno 2> /dev/null)
	[ -z "$ANDROID_SERIAL" ] && ( echo No Android device found...; exit 1 )
	type prompt_tag > /dev/null 2>&1 && prompt_tag "[ANDROID_SERIAL=$ANDROID_SERIAL]"
	echo $ANDROID_SERIAL: $@
	adb shell $@
}
alias a_=ash
a_pidof() { echo $(adb shell ps | grep "$@" | cut -c 9-15 ); }
a_pidof1() { echo $(adb shell ps | grep "$@" | cut -c 9-15 | head -1 ); }

# find
alias f=find
alias fBB='find . \( -type d -exec chmod -c 755 {} \; \) -o \( -type f -exec chmod -c 644 {} \; \)'
alias fBBx='for f in $(find -type f); do file -L $f | grep -q -E ELF\|executable && chmod -c a+x $f; done || true'
alias fdd='f . -type d'
alias ff='f . -type f'
alias ffn='ff -name'
gffn() { ffn "$1" -exec grep --color=auto -HE "$2" {} \; ; }
alias fgr='f . | grep -i --color=auto '
alias lc='locate --ignore-case --existing --regex --basename'
loc() { lc "$*" | grep --ignore-case --color "$*"; }
locl() { lc "$*" | sed -ne 's,^$'PWD',.,pi' | grep --ignore-case --color "$*"; }
locl2() { locate --wholename --regexp="^$PWD"| sed -ne "s,^$PWD,.,p" | grep --color --fixed-strings "$*"; }
alias lloc=locl
alias cq=copyq
alias df='\df -h | sort -k 6,6 | sed "/^Filesystem/d"'

# git
alias g=git
alias gc='git commit --verbose'
alias gcn='git clean -n'
alias gca='git commit --amend --verbose'
alias gcop='git checkout --patch'
alias gdf='git diff --ignore-space-change --ignore-blank-lines'
alias grp='git reset --patch'
# alias gst='git -c color.ui=always status -sb --show-stash'
alias gst='git status -sb -- '
# gst() {
#	local git_min_version="2.10.0"

# }
alias gstt='gst .'
gcr() {
	set -x
	git clone --recursive --jobs=8 --verbose $1 &&
		cd ${1:t} &&
		ranger .
	}

ghssh() {
	local dsh2_https_base='https://github.com/dsh2'
	local dsh2_ssh_base='git@github.com:dsh2'
	for remote in $(git remote); do
		remote_url=$(git remote get-url --push $remote)
		if [[ $remote_url =~ $dsh2_https_base ]]; then
			remote_url_new=${remote_url/$dsh2_https_base/$dsh2_ssh_base}
			echo Switching url \"$remote_url\" to \"$remote_url_new\"
			git remote set-url $remote --push $remote_url_new
		elif [[ $remote_url =~ $dsh2_ssh_base ]]; then
			remote_url_new=${remote_url/$dsh2_ssh_base/$dsh2_https_base}
			echo Switching url \"$remote_url\" to \"$remote_url_new\"
			git remote set-url $remote --push $remote_url_new
		else
			echo Skipping $remote_url
		fi
	done
}

alias gcrs='git clone --recursive --jobs=8 --verbose --shallow-submodules --depth 1'
alias grv='git remote --verbose'
alias gfa='git fetch --all --tags --progress --verbose'
alias gco='git checkout'
alias gcom='git checkout master'
alias gcol='git checkout local'
alias gA='mlocate -eb \\HEAD | while read p; do p=${p:h}; [[ -d $p/objects && -f $p/config ]] && echo $p; done'
alias gk='x0; gitk --all&'
alias gkk='v +GV'
alias gss='GIT_MODIFIED_FILES=$(git ls-files --modified) && [ -n $GIT_MODIFIED_FILES ] && $EDITOR $=GIT_MODIFIED_FILES +Gstatus +only'
alias gcp='git cherry-pick'
alias gpp='git pull --recurse-submodules --jobs=8 && git submodule update --init --merge --recursive'
alias gppp='gpp && git push'
alias gaa='git apply --verbose --check --3way'
# TODO: add to fbr
alias gbb='git checkout $(git for-each-ref --format="%(color:red)%(objectname:short)%(color:reset) %(HEAD) (%(color:green)%(committerdate:format:%a %F %T) - %(committerdate:relative)%(color:reset)) %09 %(color:yellow)%(refname:short)%(color:reset) %09 %(contents:subject) (%(color:green)%(authorname)%(color:reset))" --sort=committerdate  | fzf --tac --tabstop=17 --preview="git log --color --graph --pretty=format:\"%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset\" --abbrev-commit -p {1}" | cut -f 1 -d\  )'
alias gba='git branch -a -vv'
alias gcs='git config --show-origin'
alias gra='git rebase --abort'
alias grC='git rebase --continue'
alias grh='git reset HEAD^'
alias grH='git reset HEAD@{1}'
alias gsm='git submodule'
alias gsmp='git submodule foreach git pull'
alias gsmcm='git submodule foreach git checkout master'
alias gtl='git tag --sort=-taggerdate | head -1'
alias gl='git lg | less'
alias gci='git config --show-origin --get-regexp user.\*; git init && git add . && git commit -m "Initial commit"'

# ls
alias ls="$LS_COMMAND --almost-all --escape --classify --color=always --time-style='+%F %T'"
alias l='ls -lh'
alias l1='ls -1'
alias lD='l --group-directories-first'
alias lt='l -tr'
alias lts='l -rS'
alias ltsh='l -rS -h'
alias ltr='ls -al **/*(.om) '
alias ltrD='ls -dal **/*(/om) '
alias lsd='l -d'
alias fr='fc -R'
alias tt=set_terminal_title

alias tcpD='sudo setcap cap_net_raw,cap_net_admin=eip /usr/sbin/tcpdump'
alias tcpd='PCAP=~/.pcaps/tcpdump-$(nn).pcap; tcpdump --packet-buffered -w - | tee $PCAP | tcpdump -r -'
alias tsk='PCAP=~/.pcaps/tcpdump-$(nn).pcapng; tshark -Fpcapng -QWn -w - | tee $PCAP | tshark --color -r -'
# alias tsa='mergecap ~/.pcaps/*.pcapng(.rm-1) -w - | tshark -r - -qz io,phs'
alias tsa='mergecap ~/.pcaps/*.pcapng(.om[1]) -w - | tshark -r - -qz io,phs'
alias wsd='wireshark -r ~/.pcaps/tcpdump-*(.om[1])&'
alias nmap='nmap -oA ~/.nmap/log-$(nn)'
alias nmr='nmap --resume ~/.nmap/*.gnmap(.om[1])'
alias nmz='nmapfe ~/.nmap/*.xml(.om[1])'
alias ln='ln -rsv'
alias lnn=lnav
alias lvv=lnav
alias r=ranger
alias rD='ranger $(xdg-user-dir DOWNLOAD)'
alias zl='fc -rlEDt "%a %F  %T" 1 gg'
alias za='echo Sourcing ~/.aliases; time source ~/.aliases'
alias zs=zstyle
alias zz='echo exec $SHELL; exec $SHELL'
alias zzz='echo Sourcing ~/.zshrc; time source ~/.zshrc'
alias msf='./msfconsole --real-readline --quiet -r /home/dsf/.dotfiles/msfc.rc'
alias ms=msf
alias mkd='mkdir -p'
mkt() { TMP=tmp-$(nn); [[ -n $* ]] && TMP+=-${(q)*}; mkd $TMP; cd $TMP; }
mcd() {
	DIR=$*
	if [[ -z $DIR ]]; then
		echo usage: mcd NEWDIR
		return
	fi
	mkd $DIR && cd $DIR
}
alias mkp=mkd
alias goo=googler
alias wh='whence -sv'
alias whh=whence
alias prr=print
alias prl='print -rl -- '
alias prv=printenv
alias j='jobs -l'
alias jk='kill ${${(v)jobstates##*:*:}%=*}'
alias jkk='kill -9 ${${(v)jobstates##*:*:}%=*}'
alias jk9=jkk
alias d='diff -u'
alias vf=vimdiff.nvim
alias vd=vimdiff.nvim
alias wanip='dig +short myip.opendns.com ANY @resolver1.opendns.com'
alias wanip2='curl https://checkip.amazonaws.com'
alias lanip='for if in $(\ls -1 /sys/class/net); do if [ $if != "lo" -a $(cat /sys/class/net/$if/operstate) = "up" ]; then echo $if:\\t$(ifdata -pa $if); fi; done'
alias pvv=print_variables
envof() { sed 's/\x0/\n/g' /proc/${1}/environ; }
alias va=vagrant
alias doc=docker
alias dock=docker

# Vim aliases
# alias v=vim
alias v=$EDITOR
gv() { gvim "$*"; raiseX; }
# alias vl='(cd ~/.tmux-log/; v *(.om[1]))'
viminfo() { vim -R -c "Info $1 $2" -c "bdelete 1" -c "setlocal nomodifiable" ; }
vimman() { vim -R -c "Man $1 $2" -c "bdelete 1" -c "setlocal nomodifiable" -c "map Q :cq<cr>" -c "set cursorline" "+silent! /example"; }
alias m=vimman
alias mm="vimman \$(man -k . | fzf | sed -e 's,\(.*\) (\([^)]*\).*-.*,\1.\2,')"

RUN() {
	# TODO
	# -Add option to run through watch to show diffs in output
	# -Measure runtime
	# -Log output in tmux-log or similar
	# -Option to clear -x or not
	# -Press any key for manual run
	# o:=output_dir -output-dir:=output_dir \
	# t:=meassure_runtime -meassure-runtime:=meassure_runtime \
	local -a watch_objs
	if [ $# = 0 ] || ! zparseopts -D \
		w+:=watch_objs -watch+:=watch_objs \
		1=watch_run_objs \
		x=clear_screen c=clear_screen -clear=clear_screen \
		d=diff_output -diff-output=diff_output \
		s=skip_first_run -skip-first-run=skip_first_run \
		t=print_time -time=print_time \
		v=verbose -verbose=verbose \
		; then
			print "usage: RUN [--skip-first-run] [--watch_file file] executable [args]"
			return 1
	fi
	watch_objs=(${watch_objs:gs:--watch:::gs:-w::}) # HELP: This cannot be - by no means - zsh-idiomatics
	[[ $#watch_objs = 0 || -n $watch_run_objs ]] && watch_objs+=$1
	run_obj=$*
	[ -z $run_obj ] && { echo Nothing to run.; return; }
	[ $#watch_objs = 0 ] && { echo Nothing to watch.; return; }
	# TODO: Resolve target executable
	# [ ! -e $WATCH ] && WATCH=$(whence $WATCH)
	while true; do
		if [[ -z $skip_first_run ]]; then
			[[ -n $clear_screen ]] && clear -x
			if [[ -n $verbose ]]; then
				print "Watching: $watch_objs"
				print "Running: $run_obj"
			fi
			[[ -n $print_time ]] && print "Start: $(n)"
			print -P $LINE_SEPARATOR
			$=run_obj
			err=$?
			print -P $LINE_SEPARATOR
			(( err )) && err "err = $err"
			[[ -n $print_time ]] && print "Stop: $(n)"
		fi
		unset skip_first_run
		# if ! inotifywait -q -e move_self -e modify $=watch_objs > /dev/null ; then
		if ! inotifywait -q -e attrib -e move_self -e modify $=watch_objs > /dev/null ; then
			echo inotifywait failed!
			return
		fi
		# TODO: check if run failed. Add options for sleep, ignore, abort, etc.
		sleep 0.1
	done
}

# Miscellaneous
alias o=exo-open
alias a=aws
alias al='aws ec2'
alias ae='aws ec2'
alias e2='aws ec2'
alias ae2='aws ec2 describe-instances --query "Reservations[].Instances[].InstanceId" --output text --filter Name=ip-address,Values='
alias aeA='aws ec2 describe-instances --filter Name=instance-state-name,Values=running --query "Reservations[].Instances[].InstanceId" --output text'
alias aI='( for region in $(aws ec2 describe-regions --query "Regions[].RegionName" --output text); do aws --region $region ec2 describe-instances  | jq -r ".Reservations[].Instances[] | [.LaunchTime, .InstanceId, .ImageId, .InstanceType, .State.Name, [[.Tags[]?] | map(.Key + \"=\" + .Value) | .[] ] ] | flatten | @tsv" | sed "s,^,$region\t,"& done; wait ) | sort -k 2,1 '
alias aeAT="aws ec2 terminate-instances --instance-ids \$(aeA) --output table"
alias aed="aws ec2 describe-instances --instance-ids"
alias ac='aws cloudformation'
alias ax=autorandr
alias xx=xrandr
alias TCPTRACEOPTS_minimal='export TCPTRACEOPTS="--noshowdupack3 --noshowsacks --noshowrexmit --noshowoutorder"'
alias TCPTRACEOPTS_normal='export TCPTRACEOPTS='
alias Xreseed="dd if=/dev/urandom count=1 2> /dev/null | md5sum | sed -e 's,^\([! ]*\).*$,add :0 . \1,' | tee /dev/stderr | xauth"
alias le=$PAGER
alias pst=pp
alias psp='pstree -laps'
alias p_s='port search --line'
alias tm=tmux
alias tma='if tmux has-session; then tmux attach; else tmux new-session -s root -n dott "cd ~/.dotfiles; vim vimrc"; fi'
alias tmn='tmux new-session -t $(tmux list-sessions -F "#S"|head -1)'
alias tmm='TAG_NAME=$(herbstclient attr tags.focus.name) && if tmux has-session -t $TAG_NAME >/dev/null; then tmux attach-session -t $TAG_NAME; else tmux new-session -s $TAG_NAME -n $TAG_NAME; fi'
alias tmk='for s in $(tmux list-sessions -F "#{session_name}"); do if [[ $s =~ "-[0-9]*$" ]]; then echo Killing session "$s"; tmux kill-session -t $s; fi; done'
alias vp='vim -c "nmap Q :q!<cr>" -c "setlocal nomodifiable" -'
alias vpcsv='vim -c "let b:csv_headerline = 0" -c "set filetype=csv" -c "%CSVArrangeColumn!" -c "nmap Q :q!<cr>" -c "set nomodifiable" -'
alias vpp=vpcsv
alias tag=prompt_tag
gw() { grep --color -Iwri -- "$@" *; }
alias grep='grep --color'
alias pg='ping gdns |& lnav -t'
alias acs='apt-cache search'
alias r22='rabin2 -gx'
alias pl='patool list'
alias px='patool extract'
alias pd='patool diff'
alias q='qiv -uBfta '
alias bw='binwalk -veBAEJ -cf binwalk-log.csv '
alias xc='xclip -selection clipboard -in'
alias wp='echo -n $(powershell.exe Get-Clipboard)'
alias xcc='tmux show-buffer | xc'
alias M='make -j $(nproc)'
alias makev='make SHELL="PS4=__[MAKE]__\  \$\$SHELL -x"'
alias ndd=ndk-build
alias tss=typeset
alias rh=rehash
alias ipp='ipython3 -- '
alias pz=python
alias ip='ip -c'
yt() { printf "$*\nquit" | nc localhost 5038; }
xp() { echo "$*" | xc; }
alias d2u=dos2unix
alias bd=bindkey
alias bdl='bindkey -L'
alias kc='source ~/.keychain/*-sh(.om[1])'
alias Gdb='gdb -q -ex "b main" -ex run --args '
alias Ga='gdb -q -ex "set verbose" -ex "set sysroot /" -ex "set remote interrupt-sequence Ctrl-C" -ex "target remote :2000"'
alias G='gdbserver :2000'
alias fcp='fc -P'
alias func=function
alias fuc=function
alias fncc=functions
alias funcc=functions
alias fcc=functions
alias fcP=zloc
alias rmzl='find . -name .zsh_local_history -exec rm {} \;'
alias rmT='find . -name tmp-20\* -exec trash -v -- {} \; -prune'
alias sc=systemctl
alias scc=sysctl
alias sct=sysctl
alias dp=dpkg
alias dps='dpkg -S'
alias dpq=dpkg-query
alias n="date '+%F %T'"
alias nn="date '+%F__%T'"
alias tgi=telegram-cli
alias ncn=nmcli
alias ncc=nmcli
alias ncnn='nmcli dev'
alias ncnc='nmcli con'
alias hx='hexdump -C'
alias vv=voltron
alias k=kill
alias kk='kill -STOP '
alias pf=pidof
alias fu=fuser
alias cs='killall -STOP chrome; echo -n Chrome sleeping....; cat ; echo CONT; killall -CONT chrome'
alias s=stat
alias sd=sysdig
alias st='strace -s 0 -x -a $(($COLUMNS - 12)) -r -f'
alias sudo='sudo '
alias uu=uniq
alias lv=lnav
alias e=echo
alias vis=sudoedit
alias xrr='while :; do xrandr --output eDP-1 --gamma 0.$(($RANDOM%8+2)):0.$(($RANDOM%8+2)):0.$(($RANDOM%8+2)); read; done'
alias xR='xrandr --output eDP-2 --gamma 1:1:1'
rl() { file "$*" && readlink -f "$*"; }
mvO() { 
	for f in $*; do 
		if [ -e $f-OFF ]; then 
			mv -v -- $f-OFF $f
		elif [ -e $f ]; then 
			if [ $f != ${f%-OFF} ]; then
				mv -v -- $f ${f%-OFF}
			else
				mv -v -- $f $f-OFF
			fi
		else 
			echo \"$f\" not found.
		fi
	done
}
mvOFF() { for f in $*; do mv -v -- $f $f-OFF; done; }
mvON() { for f in $*; do if [ -e $f-OFF ]; then mv -v -- $f-OFF $f; elif [ -e $f ]; then if [ $f != ${f%-OFF} ]; then mv -v -- $f ${f%-OFF}; else echo \"$f\" not off; fi; else echo \"$f\" not found; fi; done; }
alias sl='echo -e Loaded keys\\n-----------; ssh-add -l; echo -----------; setopt nopipefail; for key in ~/.ssh/hosts/**/*.key; do ssh-add -c $key; done'
alias sL='tabs 15; for key in /etc/ssh/ssh_host_*(.)pub; do print -n ${key:t}\\t; ssh-keygen -lf $key; done'
alias sshl="ssh -p 22222 $USER@localhost"
alias sshc='ssh-copy-id -n -i ~/.ssh/id_rsa.pub'
alias sll='. ~/.keychain/$HOST-sh; sl'
alias Rl='ranger ~/INCOMING'
alias dcl='dynamic-colors cycle'
alias dd='dd status=progress'
alias hc=herbstclient
alias cts=curl-tesseract
alias gdb='gdb -q'
alias x0='[[ -z $DISPLAY ]] && export DISPLAY=:0'
alias x00='export DISPLAY=:0'
alias digr='dig -x'
alias y=yum

src_index() {
	find . \
		-name .repo -prune -o \
		-name .git -prune -o \
		-name out -prune -o \
		-name build -prune -o \
		-type f \( \
		-name '*.c' -o \
		-name '*.cc' -o \
		-name '*.cpp' -o \
		-name '*.h' -o \
		-name '*.hpp' \
		\) > cscope.files ; command cscope -bi cscope.files;
	}

alias s3=sqlite3
alias s3b='sqlitebrowser -R'
alias s3l='sqlitebrowser -R'
alias file='file -z'
alias d2='dnf-2'
alias sx='screen -X'
alias sxt='sx title'
alias ssv2csv="sed -re 's/([^ \"]*|\"[^\"]*\") /\1,/g; s/\"([^\"]*)\"/\1/g'"
alias slp=sleep
alias rs=rsync
alias ws=wireshark
# export WS_OPTIONS=(-o tcp.no_subdissector_on_error:false -d tcp.port==1-65535,ssl -o ssl.keylog_file:/home/dsf/PCAPS/all-pcaps.keylogfile)
# export WS_OPTIONS=(-o ssl.keylog_file:/home/dsf/PCAPS/all-pcaps.keylogfile)
alias lvs='tmux split -d lnav ssldebug'
alias tsv='truncate -s0 ssldebug'
alias ww='${WIRESHARK:-wireshark} $=WS_OPTIONS $=WS_DISABLE_PROTO -o ssl.debug_file:/dev/null -r cap.pcapng &'
alias wwss='${WIRESHARK:-wireshark} $=WS_OPTIONS $=WS_DISABLE_PROTO -o ssl.debug_file:/dev/stdout -r cap.pcapng'
alias wws='${WIRESHARK:-wireshark} $=WS_OPTIONS $=WS_DISABLE_PROTO -o ssl.debug_file:ssldebug -r cap.pcapng & truncate -s0 ssldebug'
alias wwso='${WIRESHARK:-wireshark} $=WS_OPTIONS $=WS_DISABLE_PROTO -o ssl.debug_file:ssldebug-orig -r cap.pcapng & truncate -s0 ssldebug-orig'
alias sshn='ssh -o ControlMaster=no -o ControlPath=/dev/null'
alias trim="sed -e 's,^[[:blank:]]*\(.*\)[[:blank:]],\1,'"
alias xpidof='xprop  _NET_WM_PID | cut -d= -f2 | trim'
alias xpf=xpidof
alias xps='ps axu gg $(xpidof)'
alias pss='gdb -batch -q -ex "set confirm off" -ex "set height 0" -ex "info shared" -ex "quit" -p '
alias gbt='gdb -batch -q -ex "set confirm off" -ex "set height 0" -ex "thread apply all bt" -ex "quit" -p '
# TODO: make C a zle binding
alias C='cool-retro-term --fullscreen -e /usr/bin/tmux attach DN &'
alias RR=reset
alias H=hostname
alias 1='ping 1.1.1.1'
alias 2='dig one.one.one.one @1.1.1.1'
alias 3='dig one.one.one.one @127.0.0.1'

alias rf='rfkill block all'
alias rfw='rfkill unblock wifi'
alias uf='uftrace --no-pager'
alias ufr='uftrace --no-pager record -A . -R . '
alias se=set 

# vim: se ft=sh:
